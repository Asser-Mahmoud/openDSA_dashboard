{"ast":null,"code":"/**\r\n * Keeps entries in the matrix when the callback function returns true, removes the entry otherwise\r\n *\r\n * @param {Matrix}   a              The sparse matrix\r\n * @param {function} callback       The callback function, function will be invoked with the following args:\r\n *                                    - The entry row\r\n *                                    - The entry column\r\n *                                    - The entry value\r\n *                                    - The state parameter\r\n * @param {any}      other          The state\r\n *\r\n * @return                          The number of nonzero elements in the matrix\r\n *\r\n * Reference: http://faculty.cse.tamu.edu/davis/publications.html\r\n */\nexport function csFkeep(a, callback, other) {\n  // a arrays\n  var avalues = a._values;\n  var aindex = a._index;\n  var aptr = a._ptr;\n  var asize = a._size; // columns\n\n  var n = asize[1]; // nonzero items\n\n  var nz = 0; // loop columns\n\n  for (var j = 0; j < n; j++) {\n    // get current location of col j\n    var p = aptr[j]; // record new location of col j\n\n    aptr[j] = nz;\n\n    for (; p < aptr[j + 1]; p++) {\n      // check we need to keep this item\n      if (callback(aindex[p], j, avalues ? avalues[p] : 1, other)) {\n        // keep A(i,j)\n        aindex[nz] = aindex[p]; // check we need to process values (pattern only)\n\n        if (avalues) {\n          avalues[nz] = avalues[p];\n        } // increment nonzero items\n\n\n        nz++;\n      }\n    }\n  } // finalize A\n\n\n  aptr[n] = nz; // trim arrays\n\n  aindex.splice(nz, aindex.length - nz); // check we need to process values (pattern only)\n\n  if (avalues) {\n    avalues.splice(nz, avalues.length - nz);\n  } // return number of nonzero items\n\n\n  return nz;\n}","map":{"version":3,"sources":["C:/Users/x/Desktop/openDSA/openDSA_dashboard/project/node_modules/mathjs/lib/esm/function/algebra/sparse/csFkeep.js"],"names":["csFkeep","a","callback","other","avalues","_values","aindex","_index","aptr","_ptr","asize","_size","n","nz","j","p","splice","length"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASA,OAAT,CAAiBC,CAAjB,EAAoBC,QAApB,EAA8BC,KAA9B,EAAqC;AAC1C;AACA,MAAIC,OAAO,GAAGH,CAAC,CAACI,OAAhB;AACA,MAAIC,MAAM,GAAGL,CAAC,CAACM,MAAf;AACA,MAAIC,IAAI,GAAGP,CAAC,CAACQ,IAAb;AACA,MAAIC,KAAK,GAAGT,CAAC,CAACU,KAAd,CAL0C,CAM1C;;AACA,MAAIC,CAAC,GAAGF,KAAK,CAAC,CAAD,CAAb,CAP0C,CAQ1C;;AACA,MAAIG,EAAE,GAAG,CAAT,CAT0C,CAU1C;;AACA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,CAApB,EAAuBE,CAAC,EAAxB,EAA4B;AAC1B;AACA,QAAIC,CAAC,GAAGP,IAAI,CAACM,CAAD,CAAZ,CAF0B,CAG1B;;AACAN,IAAAA,IAAI,CAACM,CAAD,CAAJ,GAAUD,EAAV;;AACA,WAAOE,CAAC,GAAGP,IAAI,CAACM,CAAC,GAAG,CAAL,CAAf,EAAwBC,CAAC,EAAzB,EAA6B;AAC3B;AACA,UAAIb,QAAQ,CAACI,MAAM,CAACS,CAAD,CAAP,EAAYD,CAAZ,EAAeV,OAAO,GAAGA,OAAO,CAACW,CAAD,CAAV,GAAgB,CAAtC,EAAyCZ,KAAzC,CAAZ,EAA6D;AAC3D;AACAG,QAAAA,MAAM,CAACO,EAAD,CAAN,GAAaP,MAAM,CAACS,CAAD,CAAnB,CAF2D,CAG3D;;AACA,YAAIX,OAAJ,EAAa;AACXA,UAAAA,OAAO,CAACS,EAAD,CAAP,GAAcT,OAAO,CAACW,CAAD,CAArB;AACD,SAN0D,CAO3D;;;AACAF,QAAAA,EAAE;AACH;AACF;AACF,GA7ByC,CA8B1C;;;AACAL,EAAAA,IAAI,CAACI,CAAD,CAAJ,GAAUC,EAAV,CA/B0C,CAgC1C;;AACAP,EAAAA,MAAM,CAACU,MAAP,CAAcH,EAAd,EAAkBP,MAAM,CAACW,MAAP,GAAgBJ,EAAlC,EAjC0C,CAkC1C;;AACA,MAAIT,OAAJ,EAAa;AACXA,IAAAA,OAAO,CAACY,MAAR,CAAeH,EAAf,EAAmBT,OAAO,CAACa,MAAR,GAAiBJ,EAApC;AACD,GArCyC,CAsC1C;;;AACA,SAAOA,EAAP;AACD","sourcesContent":["/**\r\n * Keeps entries in the matrix when the callback function returns true, removes the entry otherwise\r\n *\r\n * @param {Matrix}   a              The sparse matrix\r\n * @param {function} callback       The callback function, function will be invoked with the following args:\r\n *                                    - The entry row\r\n *                                    - The entry column\r\n *                                    - The entry value\r\n *                                    - The state parameter\r\n * @param {any}      other          The state\r\n *\r\n * @return                          The number of nonzero elements in the matrix\r\n *\r\n * Reference: http://faculty.cse.tamu.edu/davis/publications.html\r\n */\r\nexport function csFkeep(a, callback, other) {\r\n  // a arrays\r\n  var avalues = a._values;\r\n  var aindex = a._index;\r\n  var aptr = a._ptr;\r\n  var asize = a._size;\r\n  // columns\r\n  var n = asize[1];\r\n  // nonzero items\r\n  var nz = 0;\r\n  // loop columns\r\n  for (var j = 0; j < n; j++) {\r\n    // get current location of col j\r\n    var p = aptr[j];\r\n    // record new location of col j\r\n    aptr[j] = nz;\r\n    for (; p < aptr[j + 1]; p++) {\r\n      // check we need to keep this item\r\n      if (callback(aindex[p], j, avalues ? avalues[p] : 1, other)) {\r\n        // keep A(i,j)\r\n        aindex[nz] = aindex[p];\r\n        // check we need to process values (pattern only)\r\n        if (avalues) {\r\n          avalues[nz] = avalues[p];\r\n        }\r\n        // increment nonzero items\r\n        nz++;\r\n      }\r\n    }\r\n  }\r\n  // finalize A\r\n  aptr[n] = nz;\r\n  // trim arrays\r\n  aindex.splice(nz, aindex.length - nz);\r\n  // check we need to process values (pattern only)\r\n  if (avalues) {\r\n    avalues.splice(nz, avalues.length - nz);\r\n  }\r\n  // return number of nonzero items\r\n  return nz;\r\n}"]},"metadata":{},"sourceType":"module"}