{"ast":null,"code":"/* eslint-disable no-loss-of-precision */\n// References\n// ----------\n// [1] Hare, \"Computing the Principal Branch of log-Gamma\", Journal of Algorithms, 1997.\n// [2] https://math.stackexchange.com/questions/1338753/how-do-i-calculate-values-for-gamma-function-with-complex-arguments\nimport { lgammaNumber, lnSqrt2PI } from '../../plain/number/index.js';\nimport { factory } from '../../utils/factory.js';\nimport { copysign } from '../../utils/number.js';\nvar name = 'lgamma';\nvar dependencies = ['Complex', 'typed'];\nexport var createLgamma = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    Complex,\n    typed\n  } = _ref; // Stirling series is non-convergent, we need to use the recurrence `lgamma(z) = lgamma(z+1) - log z` to get\n  // sufficient accuracy.\n  //\n  // These two values are copied from Scipy implementation:\n  // https://github.com/scipy/scipy/blob/v1.8.0/scipy/special/_loggamma.pxd#L37\n\n  var SMALL_RE = 7;\n  var SMALL_IM = 7;\n  /**\r\n   * The coefficients are B[2*n]/(2*n*(2*n - 1)) where B[2*n] is the (2*n)th Bernoulli number. See (1.1) in [1].\r\n   *\r\n   * If you cannot access the paper, can also get these values from the formula in [2].\r\n   *\r\n   *    1 /     12 = 0.00833333333333333333333333333333\r\n   *    1 /    360 = 0.00277777777777777777777777777778\r\n   * ...\r\n   * 3617 / 133400 = 0.02955065359477124183006535947712\r\n   */\n\n  var coeffs = [-2.955065359477124183e-2, 6.4102564102564102564e-3, -1.9175269175269175269e-3, 8.4175084175084175084e-4, -5.952380952380952381e-4, 7.9365079365079365079e-4, -2.7777777777777777778e-3, 8.3333333333333333333e-2];\n  /**\r\n   * Logarithm of the gamma function for real, positive numbers and complex numbers,\r\n   * using Lanczos approximation for numbers and Stirling series for complex numbers.\r\n   *\r\n   * Syntax:\r\n   *\r\n   *    math.lgamma(n)\r\n   *\r\n   * Examples:\r\n   *\r\n   *    math.lgamma(5)       // returns 3.178053830347945\r\n   *    math.lgamma(0)       // returns Infinity\r\n   *    math.lgamma(-0.5)    // returns NaN\r\n   *    math.lgamma(math.i)  // returns -0.6509231993018536 - 1.8724366472624294i\r\n   *\r\n   * See also:\r\n   *\r\n   *    gamma\r\n   *\r\n   * @param {number | Complex} n   A real or complex number\r\n   * @return {number | Complex}    The log gamma of `n`\r\n   */\n\n  return typed(name, {\n    number: lgammaNumber,\n    Complex: lgammaComplex,\n    BigNumber: function BigNumber() {\n      throw new Error(\"mathjs doesn't yet provide an implementation of the algorithm lgamma for BigNumber\");\n    }\n  });\n\n  function lgammaComplex(n) {\n    var TWOPI = 6.2831853071795864769252842; // 2*pi\n\n    var LOGPI = 1.1447298858494001741434262; // log(pi)\n\n    var REFLECTION = 0.1;\n\n    if (n.isNaN()) {\n      return new Complex(NaN, NaN);\n    } else if (n.im === 0) {\n      return new Complex(lgammaNumber(n.re), 0);\n    } else if (n.re >= SMALL_RE || Math.abs(n.im) >= SMALL_IM) {\n      return lgammaStirling(n);\n    } else if (n.re <= REFLECTION) {\n      // Reflection formula. see Proposition 3.1 in [1]\n      var tmp = copysign(TWOPI, n.im) * Math.floor(0.5 * n.re + 0.25);\n      var a = n.mul(Math.PI).sin().log();\n      var b = lgammaComplex(new Complex(1 - n.re, -n.im));\n      return new Complex(LOGPI, tmp).sub(a).sub(b);\n    } else if (n.im >= 0) {\n      return lgammaRecurrence(n);\n    } else {\n      return lgammaRecurrence(n.conjugate()).conjugate();\n    }\n  }\n\n  function lgammaStirling(z) {\n    // formula ref in [2]\n    // computation ref:\n    // https://github.com/scipy/scipy/blob/v1.8.0/scipy/special/_loggamma.pxd#L101\n    // left part\n    // x (log(x) - 1) + 1/2 (log(2PI) - log(x))\n    // => (x - 0.5) * log(x) - x + log(2PI) / 2\n    var leftPart = z.sub(0.5).mul(z.log()).sub(z).add(lnSqrt2PI); // right part\n\n    var rz = new Complex(1, 0).div(z);\n    var rzz = rz.div(z);\n    var a = coeffs[0];\n    var b = coeffs[1];\n    var r = 2 * rzz.re;\n    var s = rzz.re * rzz.re + rzz.im * rzz.im;\n\n    for (var i = 2; i < 8; i++) {\n      var tmp = b;\n      b = -s * a + coeffs[i];\n      a = r * a + tmp;\n    }\n\n    var rightPart = rz.mul(rzz.mul(a).add(b)); // plus left and right\n\n    return leftPart.add(rightPart);\n  }\n\n  function lgammaRecurrence(z) {\n    // computation ref:\n    // https://github.com/scipy/scipy/blob/v1.8.0/scipy/special/_loggamma.pxd#L78\n    var signflips = 0;\n    var sb = 0;\n    var shiftprod = z;\n    z = z.add(1);\n\n    while (z.re <= SMALL_RE) {\n      shiftprod = shiftprod.mul(z);\n      var nsb = shiftprod.im < 0 ? 1 : 0;\n      if (nsb !== 0 && sb === 0) signflips++;\n      sb = nsb;\n      z = z.add(1);\n    }\n\n    return lgammaStirling(z).sub(shiftprod.log()).sub(new Complex(0, signflips * 2 * Math.PI * 1));\n  }\n});","map":{"version":3,"sources":["C:/Users/x/Desktop/openDSA/openDSA_dashboard/project/node_modules/mathjs/lib/esm/function/probability/lgamma.js"],"names":["lgammaNumber","lnSqrt2PI","factory","copysign","name","dependencies","createLgamma","_ref","Complex","typed","SMALL_RE","SMALL_IM","coeffs","number","lgammaComplex","BigNumber","Error","n","TWOPI","LOGPI","REFLECTION","isNaN","NaN","im","re","Math","abs","lgammaStirling","tmp","floor","a","mul","PI","sin","log","b","sub","lgammaRecurrence","conjugate","z","leftPart","add","rz","div","rzz","r","s","i","rightPart","signflips","sb","shiftprod","nsb"],"mappings":"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","sourcesContent":["/* eslint-disable no-loss-of-precision */\r\n\r\n// References\r\n// ----------\r\n// [1] Hare, \"Computing the Principal Branch of log-Gamma\", Journal of Algorithms, 1997.\r\n// [2] https://math.stackexchange.com/questions/1338753/how-do-i-calculate-values-for-gamma-function-with-complex-arguments\r\n\r\nimport { lgammaNumber, lnSqrt2PI } from '../../plain/number/index.js';\r\nimport { factory } from '../../utils/factory.js';\r\nimport { copysign } from '../../utils/number.js';\r\nvar name = 'lgamma';\r\nvar dependencies = ['Complex', 'typed'];\r\nexport var createLgamma = /* #__PURE__ */factory(name, dependencies, _ref => {\r\n  var {\r\n    Complex,\r\n    typed\r\n  } = _ref;\r\n  // Stirling series is non-convergent, we need to use the recurrence `lgamma(z) = lgamma(z+1) - log z` to get\r\n  // sufficient accuracy.\r\n  //\r\n  // These two values are copied from Scipy implementation:\r\n  // https://github.com/scipy/scipy/blob/v1.8.0/scipy/special/_loggamma.pxd#L37\r\n  var SMALL_RE = 7;\r\n  var SMALL_IM = 7;\r\n\r\n  /**\r\n   * The coefficients are B[2*n]/(2*n*(2*n - 1)) where B[2*n] is the (2*n)th Bernoulli number. See (1.1) in [1].\r\n   *\r\n   * If you cannot access the paper, can also get these values from the formula in [2].\r\n   *\r\n   *    1 /     12 = 0.00833333333333333333333333333333\r\n   *    1 /    360 = 0.00277777777777777777777777777778\r\n   * ...\r\n   * 3617 / 133400 = 0.02955065359477124183006535947712\r\n   */\r\n  var coeffs = [-2.955065359477124183e-2, 6.4102564102564102564e-3, -1.9175269175269175269e-3, 8.4175084175084175084e-4, -5.952380952380952381e-4, 7.9365079365079365079e-4, -2.7777777777777777778e-3, 8.3333333333333333333e-2];\r\n\r\n  /**\r\n   * Logarithm of the gamma function for real, positive numbers and complex numbers,\r\n   * using Lanczos approximation for numbers and Stirling series for complex numbers.\r\n   *\r\n   * Syntax:\r\n   *\r\n   *    math.lgamma(n)\r\n   *\r\n   * Examples:\r\n   *\r\n   *    math.lgamma(5)       // returns 3.178053830347945\r\n   *    math.lgamma(0)       // returns Infinity\r\n   *    math.lgamma(-0.5)    // returns NaN\r\n   *    math.lgamma(math.i)  // returns -0.6509231993018536 - 1.8724366472624294i\r\n   *\r\n   * See also:\r\n   *\r\n   *    gamma\r\n   *\r\n   * @param {number | Complex} n   A real or complex number\r\n   * @return {number | Complex}    The log gamma of `n`\r\n   */\r\n  return typed(name, {\r\n    number: lgammaNumber,\r\n    Complex: lgammaComplex,\r\n    BigNumber: function BigNumber() {\r\n      throw new Error(\"mathjs doesn't yet provide an implementation of the algorithm lgamma for BigNumber\");\r\n    }\r\n  });\r\n  function lgammaComplex(n) {\r\n    var TWOPI = 6.2831853071795864769252842; // 2*pi\r\n    var LOGPI = 1.1447298858494001741434262; // log(pi)\r\n\r\n    var REFLECTION = 0.1;\r\n    if (n.isNaN()) {\r\n      return new Complex(NaN, NaN);\r\n    } else if (n.im === 0) {\r\n      return new Complex(lgammaNumber(n.re), 0);\r\n    } else if (n.re >= SMALL_RE || Math.abs(n.im) >= SMALL_IM) {\r\n      return lgammaStirling(n);\r\n    } else if (n.re <= REFLECTION) {\r\n      // Reflection formula. see Proposition 3.1 in [1]\r\n      var tmp = copysign(TWOPI, n.im) * Math.floor(0.5 * n.re + 0.25);\r\n      var a = n.mul(Math.PI).sin().log();\r\n      var b = lgammaComplex(new Complex(1 - n.re, -n.im));\r\n      return new Complex(LOGPI, tmp).sub(a).sub(b);\r\n    } else if (n.im >= 0) {\r\n      return lgammaRecurrence(n);\r\n    } else {\r\n      return lgammaRecurrence(n.conjugate()).conjugate();\r\n    }\r\n  }\r\n  function lgammaStirling(z) {\r\n    // formula ref in [2]\r\n    // computation ref:\r\n    // https://github.com/scipy/scipy/blob/v1.8.0/scipy/special/_loggamma.pxd#L101\r\n\r\n    // left part\r\n\r\n    // x (log(x) - 1) + 1/2 (log(2PI) - log(x))\r\n    // => (x - 0.5) * log(x) - x + log(2PI) / 2\r\n    var leftPart = z.sub(0.5).mul(z.log()).sub(z).add(lnSqrt2PI);\r\n\r\n    // right part\r\n\r\n    var rz = new Complex(1, 0).div(z);\r\n    var rzz = rz.div(z);\r\n    var a = coeffs[0];\r\n    var b = coeffs[1];\r\n    var r = 2 * rzz.re;\r\n    var s = rzz.re * rzz.re + rzz.im * rzz.im;\r\n    for (var i = 2; i < 8; i++) {\r\n      var tmp = b;\r\n      b = -s * a + coeffs[i];\r\n      a = r * a + tmp;\r\n    }\r\n    var rightPart = rz.mul(rzz.mul(a).add(b));\r\n\r\n    // plus left and right\r\n\r\n    return leftPart.add(rightPart);\r\n  }\r\n  function lgammaRecurrence(z) {\r\n    // computation ref:\r\n    // https://github.com/scipy/scipy/blob/v1.8.0/scipy/special/_loggamma.pxd#L78\r\n\r\n    var signflips = 0;\r\n    var sb = 0;\r\n    var shiftprod = z;\r\n    z = z.add(1);\r\n    while (z.re <= SMALL_RE) {\r\n      shiftprod = shiftprod.mul(z);\r\n      var nsb = shiftprod.im < 0 ? 1 : 0;\r\n      if (nsb !== 0 && sb === 0) signflips++;\r\n      sb = nsb;\r\n      z = z.add(1);\r\n    }\r\n    return lgammaStirling(z).sub(shiftprod.log()).sub(new Complex(0, signflips * 2 * Math.PI * 1));\r\n  }\r\n});"]},"metadata":{},"sourceType":"module"}