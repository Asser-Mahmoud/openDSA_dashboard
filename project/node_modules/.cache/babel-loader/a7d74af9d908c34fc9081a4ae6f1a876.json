{"ast":null,"code":"import { containsCollections } from '../../utils/collection.js';\nimport { factory } from '../../utils/factory.js';\nimport { _switch } from '../../utils/switch.js';\nimport { improveErrorMessage } from './utils/improveErrorMessage.js';\nimport { arraySize } from '../../utils/array.js';\nimport { IndexError } from '../../error/IndexError.js';\nvar name = 'cumsum';\nvar dependencies = ['typed', 'add', 'unaryPlus'];\nexport var createCumSum = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    add,\n    unaryPlus\n  } = _ref;\n  /**\r\n   * Compute the cumulative sum of a matrix or a list with values.\r\n   * In case of a (multi dimensional) array or matrix, the cumulative sums\r\n   * along a specified dimension (defaulting to the first) will be calculated.\r\n   *\r\n   * Syntax:\r\n   *\r\n   *     math.cumsum(a, b, c, ...)\r\n   *     math.cumsum(A)\r\n   *\r\n   * Examples:\r\n   *\r\n   *     math.cumsum(2, 1, 4, 3)               // returns [2, 3, 7, 10]\r\n   *     math.cumsum([2, 1, 4, 3])             // returns [2, 3, 7, 10]\r\n   *     math.cumsum([[1, 2], [3, 4]])         // returns [[1, 2], [4, 6]]\r\n   *     math.cumsum([[1, 2], [3, 4]], 0)      // returns [[1, 2], [4, 6]]\r\n   *     math.cumsum([[1, 2], [3, 4]], 1)      // returns [[1, 3], [3, 7]]\r\n   *     math.cumsum([[2, 5], [4, 3], [1, 7]]) // returns [[2, 5], [6, 8], [7, 15]]\r\n   *\r\n   * See also:\r\n   *\r\n   *    mean, median, min, max, prod, std, variance, sum\r\n   *\r\n   * @param {... *} args  A single matrix or or multiple scalar values\r\n   * @return {*} The cumulative sum of all values\r\n   */\n\n  return typed(name, {\n    // sum([a, b, c, d, ...])\n    Array: _cumsum,\n    Matrix: function Matrix(matrix) {\n      return matrix.create(_cumsum(matrix.valueOf()));\n    },\n    // sum([a, b, c, d, ...], dim)\n    'Array, number | BigNumber': _ncumSumDim,\n    'Matrix, number | BigNumber': function MatrixNumberBigNumber(matrix, dim) {\n      return matrix.create(_ncumSumDim(matrix.valueOf(), dim));\n    },\n    // cumsum(a, b, c, d, ...)\n    '...': function _(args) {\n      if (containsCollections(args)) {\n        throw new TypeError('All values expected to be scalar in function cumsum');\n      }\n\n      return _cumsum(args);\n    }\n  });\n  /**\r\n     * Recursively calculate the cumulative sum of an n-dimensional array\r\n     * @param {Array} array\r\n     * @return {number} cumsum\r\n     * @private\r\n     */\n\n  function _cumsum(array) {\n    try {\n      return _cumsummap(array);\n    } catch (err) {\n      throw improveErrorMessage(err, name);\n    }\n  }\n\n  function _cumsummap(array) {\n    if (array.length === 0) {\n      return [];\n    }\n\n    var sums = [unaryPlus(array[0])]; // unaryPlus converts to number if need be\n\n    for (var i = 1; i < array.length; ++i) {\n      // Must use add below and not addScalar for the case of summing a\n      // 2+-dimensional array along the 0th dimension (the row vectors,\n      // or higher-d analogues, are literally added to each other).\n      sums.push(add(sums[i - 1], array[i]));\n    }\n\n    return sums;\n  }\n\n  function _ncumSumDim(array, dim) {\n    var size = arraySize(array);\n\n    if (dim < 0 || dim >= size.length) {\n      // TODO: would be more clear when throwing a DimensionError here\n      throw new IndexError(dim, size.length);\n    }\n\n    try {\n      return _cumsumDimensional(array, dim);\n    } catch (err) {\n      throw improveErrorMessage(err, name);\n    }\n  }\n  /* Possible TODO: Refactor _reduce in collection.js to be able to work here as well */\n\n\n  function _cumsumDimensional(mat, dim) {\n    var i, ret, tran;\n\n    if (dim <= 0) {\n      var initialValue = mat[0][0];\n\n      if (!Array.isArray(initialValue)) {\n        return _cumsummap(mat);\n      } else {\n        tran = _switch(mat);\n        ret = [];\n\n        for (i = 0; i < tran.length; i++) {\n          ret[i] = _cumsumDimensional(tran[i], dim - 1);\n        }\n\n        return ret;\n      }\n    } else {\n      ret = [];\n\n      for (i = 0; i < mat.length; i++) {\n        ret[i] = _cumsumDimensional(mat[i], dim - 1);\n      }\n\n      return ret;\n    }\n  }\n});","map":{"version":3,"sources":["C:/Users/amase/Desktop/open_dsa/openDSA_dashboard/project/node_modules/mathjs/lib/esm/function/statistics/cumsum.js"],"names":["containsCollections","factory","_switch","improveErrorMessage","arraySize","IndexError","name","dependencies","createCumSum","_ref","typed","add","unaryPlus","Array","_cumsum","Matrix","matrix","create","valueOf","_ncumSumDim","MatrixNumberBigNumber","dim","_","args","TypeError","array","_cumsummap","err","length","sums","i","push","size","_cumsumDimensional","mat","ret","tran","initialValue","isArray"],"mappings":"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","sourcesContent":["import { containsCollections } from '../../utils/collection.js';\r\nimport { factory } from '../../utils/factory.js';\r\nimport { _switch } from '../../utils/switch.js';\r\nimport { improveErrorMessage } from './utils/improveErrorMessage.js';\r\nimport { arraySize } from '../../utils/array.js';\r\nimport { IndexError } from '../../error/IndexError.js';\r\nvar name = 'cumsum';\r\nvar dependencies = ['typed', 'add', 'unaryPlus'];\r\nexport var createCumSum = /* #__PURE__ */factory(name, dependencies, _ref => {\r\n  var {\r\n    typed,\r\n    add,\r\n    unaryPlus\r\n  } = _ref;\r\n  /**\r\n   * Compute the cumulative sum of a matrix or a list with values.\r\n   * In case of a (multi dimensional) array or matrix, the cumulative sums\r\n   * along a specified dimension (defaulting to the first) will be calculated.\r\n   *\r\n   * Syntax:\r\n   *\r\n   *     math.cumsum(a, b, c, ...)\r\n   *     math.cumsum(A)\r\n   *\r\n   * Examples:\r\n   *\r\n   *     math.cumsum(2, 1, 4, 3)               // returns [2, 3, 7, 10]\r\n   *     math.cumsum([2, 1, 4, 3])             // returns [2, 3, 7, 10]\r\n   *     math.cumsum([[1, 2], [3, 4]])         // returns [[1, 2], [4, 6]]\r\n   *     math.cumsum([[1, 2], [3, 4]], 0)      // returns [[1, 2], [4, 6]]\r\n   *     math.cumsum([[1, 2], [3, 4]], 1)      // returns [[1, 3], [3, 7]]\r\n   *     math.cumsum([[2, 5], [4, 3], [1, 7]]) // returns [[2, 5], [6, 8], [7, 15]]\r\n   *\r\n   * See also:\r\n   *\r\n   *    mean, median, min, max, prod, std, variance, sum\r\n   *\r\n   * @param {... *} args  A single matrix or or multiple scalar values\r\n   * @return {*} The cumulative sum of all values\r\n   */\r\n  return typed(name, {\r\n    // sum([a, b, c, d, ...])\r\n    Array: _cumsum,\r\n    Matrix: function Matrix(matrix) {\r\n      return matrix.create(_cumsum(matrix.valueOf()));\r\n    },\r\n    // sum([a, b, c, d, ...], dim)\r\n    'Array, number | BigNumber': _ncumSumDim,\r\n    'Matrix, number | BigNumber': function MatrixNumberBigNumber(matrix, dim) {\r\n      return matrix.create(_ncumSumDim(matrix.valueOf(), dim));\r\n    },\r\n    // cumsum(a, b, c, d, ...)\r\n    '...': function _(args) {\r\n      if (containsCollections(args)) {\r\n        throw new TypeError('All values expected to be scalar in function cumsum');\r\n      }\r\n      return _cumsum(args);\r\n    }\r\n  });\r\n\r\n  /**\r\n     * Recursively calculate the cumulative sum of an n-dimensional array\r\n     * @param {Array} array\r\n     * @return {number} cumsum\r\n     * @private\r\n     */\r\n  function _cumsum(array) {\r\n    try {\r\n      return _cumsummap(array);\r\n    } catch (err) {\r\n      throw improveErrorMessage(err, name);\r\n    }\r\n  }\r\n  function _cumsummap(array) {\r\n    if (array.length === 0) {\r\n      return [];\r\n    }\r\n    var sums = [unaryPlus(array[0])]; // unaryPlus converts to number if need be\r\n    for (var i = 1; i < array.length; ++i) {\r\n      // Must use add below and not addScalar for the case of summing a\r\n      // 2+-dimensional array along the 0th dimension (the row vectors,\r\n      // or higher-d analogues, are literally added to each other).\r\n      sums.push(add(sums[i - 1], array[i]));\r\n    }\r\n    return sums;\r\n  }\r\n  function _ncumSumDim(array, dim) {\r\n    var size = arraySize(array);\r\n    if (dim < 0 || dim >= size.length) {\r\n      // TODO: would be more clear when throwing a DimensionError here\r\n      throw new IndexError(dim, size.length);\r\n    }\r\n    try {\r\n      return _cumsumDimensional(array, dim);\r\n    } catch (err) {\r\n      throw improveErrorMessage(err, name);\r\n    }\r\n  }\r\n\r\n  /* Possible TODO: Refactor _reduce in collection.js to be able to work here as well */\r\n  function _cumsumDimensional(mat, dim) {\r\n    var i, ret, tran;\r\n    if (dim <= 0) {\r\n      var initialValue = mat[0][0];\r\n      if (!Array.isArray(initialValue)) {\r\n        return _cumsummap(mat);\r\n      } else {\r\n        tran = _switch(mat);\r\n        ret = [];\r\n        for (i = 0; i < tran.length; i++) {\r\n          ret[i] = _cumsumDimensional(tran[i], dim - 1);\r\n        }\r\n        return ret;\r\n      }\r\n    } else {\r\n      ret = [];\r\n      for (i = 0; i < mat.length; i++) {\r\n        ret[i] = _cumsumDimensional(mat[i], dim - 1);\r\n      }\r\n      return ret;\r\n    }\r\n  }\r\n});"]},"metadata":{},"sourceType":"module"}