{"ast":null,"code":"import { factory } from '../../utils/factory.js';\nvar name = 'Spa';\nvar dependencies = ['addScalar', 'equalScalar', 'FibonacciHeap'];\nexport var createSpaClass = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    addScalar,\n    equalScalar,\n    FibonacciHeap\n  } = _ref;\n  /**\r\n   * An ordered Sparse Accumulator is a representation for a sparse vector that includes a dense array\r\n   * of the vector elements and an ordered list of non-zero elements.\r\n   */\n\n  function Spa() {\n    if (!(this instanceof Spa)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    } // allocate vector, TODO use typed arrays\n\n\n    this._values = [];\n    this._heap = new FibonacciHeap();\n  }\n  /**\r\n   * Attach type information\r\n   */\n\n\n  Spa.prototype.type = 'Spa';\n  Spa.prototype.isSpa = true;\n  /**\r\n   * Set the value for index i.\r\n   *\r\n   * @param {number} i                       The index\r\n   * @param {number | BigNumber | Complex}   The value at index i\r\n   */\n\n  Spa.prototype.set = function (i, v) {\n    // check we have a value @ i\n    if (!this._values[i]) {\n      // insert in heap\n      var node = this._heap.insert(i, v); // set the value @ i\n\n\n      this._values[i] = node;\n    } else {\n      // update the value @ i\n      this._values[i].value = v;\n    }\n  };\n\n  Spa.prototype.get = function (i) {\n    var node = this._values[i];\n\n    if (node) {\n      return node.value;\n    }\n\n    return 0;\n  };\n\n  Spa.prototype.accumulate = function (i, v) {\n    // node @ i\n    var node = this._values[i];\n\n    if (!node) {\n      // insert in heap\n      node = this._heap.insert(i, v); // initialize value\n\n      this._values[i] = node;\n    } else {\n      // accumulate value\n      node.value = addScalar(node.value, v);\n    }\n  };\n\n  Spa.prototype.forEach = function (from, to, callback) {\n    // references\n    var heap = this._heap;\n    var values = this._values; // nodes\n\n    var nodes = []; // node with minimum key, save it\n\n    var node = heap.extractMinimum();\n\n    if (node) {\n      nodes.push(node);\n    } // extract nodes from heap (ordered)\n\n\n    while (node && node.key <= to) {\n      // check it is in range\n      if (node.key >= from) {\n        // check value is not zero\n        if (!equalScalar(node.value, 0)) {\n          // invoke callback\n          callback(node.key, node.value, this);\n        }\n      } // extract next node, save it\n\n\n      node = heap.extractMinimum();\n\n      if (node) {\n        nodes.push(node);\n      }\n    } // reinsert all nodes in heap\n\n\n    for (var i = 0; i < nodes.length; i++) {\n      // current node\n      var n = nodes[i]; // insert node in heap\n\n      node = heap.insert(n.key, n.value); // update values\n\n      values[node.key] = node;\n    }\n  };\n\n  Spa.prototype.swap = function (i, j) {\n    // node @ i and j\n    var nodei = this._values[i];\n    var nodej = this._values[j]; // check we need to insert indeces\n\n    if (!nodei && nodej) {\n      // insert in heap\n      nodei = this._heap.insert(i, nodej.value); // remove from heap\n\n      this._heap.remove(nodej); // set values\n\n\n      this._values[i] = nodei;\n      this._values[j] = undefined;\n    } else if (nodei && !nodej) {\n      // insert in heap\n      nodej = this._heap.insert(j, nodei.value); // remove from heap\n\n      this._heap.remove(nodei); // set values\n\n\n      this._values[j] = nodej;\n      this._values[i] = undefined;\n    } else if (nodei && nodej) {\n      // swap values\n      var v = nodei.value;\n      nodei.value = nodej.value;\n      nodej.value = v;\n    }\n  };\n\n  return Spa;\n}, {\n  isClass: true\n});","map":{"version":3,"sources":["C:/Users/x/Desktop/openDSA/openDSA_dashboard/project/node_modules/mathjs/lib/esm/type/matrix/Spa.js"],"names":["factory","name","dependencies","createSpaClass","_ref","addScalar","equalScalar","FibonacciHeap","Spa","SyntaxError","_values","_heap","prototype","type","isSpa","set","i","v","node","insert","value","get","accumulate","forEach","from","to","callback","heap","values","nodes","extractMinimum","push","key","length","n","swap","j","nodei","nodej","remove","undefined","isClass"],"mappings":"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","sourcesContent":["import { factory } from '../../utils/factory.js';\r\nvar name = 'Spa';\r\nvar dependencies = ['addScalar', 'equalScalar', 'FibonacciHeap'];\r\nexport var createSpaClass = /* #__PURE__ */factory(name, dependencies, _ref => {\r\n  var {\r\n    addScalar,\r\n    equalScalar,\r\n    FibonacciHeap\r\n  } = _ref;\r\n  /**\r\n   * An ordered Sparse Accumulator is a representation for a sparse vector that includes a dense array\r\n   * of the vector elements and an ordered list of non-zero elements.\r\n   */\r\n  function Spa() {\r\n    if (!(this instanceof Spa)) {\r\n      throw new SyntaxError('Constructor must be called with the new operator');\r\n    }\r\n\r\n    // allocate vector, TODO use typed arrays\r\n    this._values = [];\r\n    this._heap = new FibonacciHeap();\r\n  }\r\n\r\n  /**\r\n   * Attach type information\r\n   */\r\n  Spa.prototype.type = 'Spa';\r\n  Spa.prototype.isSpa = true;\r\n\r\n  /**\r\n   * Set the value for index i.\r\n   *\r\n   * @param {number} i                       The index\r\n   * @param {number | BigNumber | Complex}   The value at index i\r\n   */\r\n  Spa.prototype.set = function (i, v) {\r\n    // check we have a value @ i\r\n    if (!this._values[i]) {\r\n      // insert in heap\r\n      var node = this._heap.insert(i, v);\r\n      // set the value @ i\r\n      this._values[i] = node;\r\n    } else {\r\n      // update the value @ i\r\n      this._values[i].value = v;\r\n    }\r\n  };\r\n  Spa.prototype.get = function (i) {\r\n    var node = this._values[i];\r\n    if (node) {\r\n      return node.value;\r\n    }\r\n    return 0;\r\n  };\r\n  Spa.prototype.accumulate = function (i, v) {\r\n    // node @ i\r\n    var node = this._values[i];\r\n    if (!node) {\r\n      // insert in heap\r\n      node = this._heap.insert(i, v);\r\n      // initialize value\r\n      this._values[i] = node;\r\n    } else {\r\n      // accumulate value\r\n      node.value = addScalar(node.value, v);\r\n    }\r\n  };\r\n  Spa.prototype.forEach = function (from, to, callback) {\r\n    // references\r\n    var heap = this._heap;\r\n    var values = this._values;\r\n    // nodes\r\n    var nodes = [];\r\n    // node with minimum key, save it\r\n    var node = heap.extractMinimum();\r\n    if (node) {\r\n      nodes.push(node);\r\n    }\r\n    // extract nodes from heap (ordered)\r\n    while (node && node.key <= to) {\r\n      // check it is in range\r\n      if (node.key >= from) {\r\n        // check value is not zero\r\n        if (!equalScalar(node.value, 0)) {\r\n          // invoke callback\r\n          callback(node.key, node.value, this);\r\n        }\r\n      }\r\n      // extract next node, save it\r\n      node = heap.extractMinimum();\r\n      if (node) {\r\n        nodes.push(node);\r\n      }\r\n    }\r\n    // reinsert all nodes in heap\r\n    for (var i = 0; i < nodes.length; i++) {\r\n      // current node\r\n      var n = nodes[i];\r\n      // insert node in heap\r\n      node = heap.insert(n.key, n.value);\r\n      // update values\r\n      values[node.key] = node;\r\n    }\r\n  };\r\n  Spa.prototype.swap = function (i, j) {\r\n    // node @ i and j\r\n    var nodei = this._values[i];\r\n    var nodej = this._values[j];\r\n    // check we need to insert indeces\r\n    if (!nodei && nodej) {\r\n      // insert in heap\r\n      nodei = this._heap.insert(i, nodej.value);\r\n      // remove from heap\r\n      this._heap.remove(nodej);\r\n      // set values\r\n      this._values[i] = nodei;\r\n      this._values[j] = undefined;\r\n    } else if (nodei && !nodej) {\r\n      // insert in heap\r\n      nodej = this._heap.insert(j, nodei.value);\r\n      // remove from heap\r\n      this._heap.remove(nodei);\r\n      // set values\r\n      this._values[j] = nodej;\r\n      this._values[i] = undefined;\r\n    } else if (nodei && nodej) {\r\n      // swap values\r\n      var v = nodei.value;\r\n      nodei.value = nodej.value;\r\n      nodej.value = v;\r\n    }\r\n  };\r\n  return Spa;\r\n}, {\r\n  isClass: true\r\n});"]},"metadata":{},"sourceType":"module"}