{"ast":null,"code":"import { clone } from '../../../utils/object.js';\nimport { factory } from '../../../utils/factory.js';\nvar name = 'lup';\nvar dependencies = ['typed', 'matrix', 'abs', 'addScalar', 'divideScalar', 'multiplyScalar', 'subtract', 'larger', 'equalScalar', 'unaryMinus', 'DenseMatrix', 'SparseMatrix', 'Spa'];\nexport var createLup = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    matrix,\n    abs,\n    addScalar,\n    divideScalar,\n    multiplyScalar,\n    subtract,\n    larger,\n    equalScalar,\n    unaryMinus,\n    DenseMatrix,\n    SparseMatrix,\n    Spa\n  } = _ref;\n  /**\r\n   * Calculate the Matrix LU decomposition with partial pivoting. Matrix `A` is decomposed in two matrices (`L`, `U`) and a\r\n   * row permutation vector `p` where `A[p,:] = L * U`\r\n   *\r\n   * Syntax:\r\n   *\r\n   *    math.lup(A)\r\n   *\r\n   * Example:\r\n   *\r\n   *    const m = [[2, 1], [1, 4]]\r\n   *    const r = math.lup(m)\r\n   *    // r = {\r\n   *    //   L: [[1, 0], [0.5, 1]],\r\n   *    //   U: [[2, 1], [0, 3.5]],\r\n   *    //   P: [0, 1]\r\n   *    // }\r\n   *\r\n   * See also:\r\n   *\r\n   *    slu, lsolve, lusolve, usolve\r\n   *\r\n   * @param {Matrix | Array} A    A two dimensional matrix or array for which to get the LUP decomposition.\r\n   *\r\n   * @return {{L: Array | Matrix, U: Array | Matrix, P: Array.<number>}} The lower triangular matrix, the upper triangular matrix and the permutation matrix.\r\n   */\n\n  return typed(name, {\n    DenseMatrix: function DenseMatrix(m) {\n      return _denseLUP(m);\n    },\n    SparseMatrix: function SparseMatrix(m) {\n      return _sparseLUP(m);\n    },\n    Array: function Array(a) {\n      // create dense matrix from array\n      var m = matrix(a); // lup, use matrix implementation\n\n      var r = _denseLUP(m); // result\n\n\n      return {\n        L: r.L.valueOf(),\n        U: r.U.valueOf(),\n        p: r.p\n      };\n    }\n  });\n\n  function _denseLUP(m) {\n    // rows & columns\n    var rows = m._size[0];\n    var columns = m._size[1]; // minimum rows and columns\n\n    var n = Math.min(rows, columns); // matrix array, clone original data\n\n    var data = clone(m._data); // l matrix arrays\n\n    var ldata = [];\n    var lsize = [rows, n]; // u matrix arrays\n\n    var udata = [];\n    var usize = [n, columns]; // vars\n\n    var i, j, k; // permutation vector\n\n    var p = [];\n\n    for (i = 0; i < rows; i++) {\n      p[i] = i;\n    } // loop columns\n\n\n    for (j = 0; j < columns; j++) {\n      // skip first column in upper triangular matrix\n      if (j > 0) {\n        // loop rows\n        for (i = 0; i < rows; i++) {\n          // min i,j\n          var min = Math.min(i, j); // v[i, j]\n\n          var s = 0; // loop up to min\n\n          for (k = 0; k < min; k++) {\n            // s = l[i, k] - data[k, j]\n            s = addScalar(s, multiplyScalar(data[i][k], data[k][j]));\n          }\n\n          data[i][j] = subtract(data[i][j], s);\n        }\n      } // row with larger value in cvector, row >= j\n\n\n      var pi = j;\n      var pabsv = 0;\n      var vjj = 0; // loop rows\n\n      for (i = j; i < rows; i++) {\n        // data @ i, j\n        var v = data[i][j]; // absolute value\n\n        var absv = abs(v); // value is greater than pivote value\n\n        if (larger(absv, pabsv)) {\n          // store row\n          pi = i; // update max value\n\n          pabsv = absv; // value @ [j, j]\n\n          vjj = v;\n        }\n      } // swap rows (j <-> pi)\n\n\n      if (j !== pi) {\n        // swap values j <-> pi in p\n        p[j] = [p[pi], p[pi] = p[j]][0]; // swap j <-> pi in data\n\n        DenseMatrix._swapRows(j, pi, data);\n      } // check column is in lower triangular matrix\n\n\n      if (j < rows) {\n        // loop rows (lower triangular matrix)\n        for (i = j + 1; i < rows; i++) {\n          // value @ i, j\n          var vij = data[i][j];\n\n          if (!equalScalar(vij, 0)) {\n            // update data\n            data[i][j] = divideScalar(data[i][j], vjj);\n          }\n        }\n      }\n    } // loop columns\n\n\n    for (j = 0; j < columns; j++) {\n      // loop rows\n      for (i = 0; i < rows; i++) {\n        // initialize row in arrays\n        if (j === 0) {\n          // check row exists in upper triangular matrix\n          if (i < columns) {\n            // U\n            udata[i] = [];\n          } // L\n\n\n          ldata[i] = [];\n        } // check we are in the upper triangular matrix\n\n\n        if (i < j) {\n          // check row exists in upper triangular matrix\n          if (i < columns) {\n            // U\n            udata[i][j] = data[i][j];\n          } // check column exists in lower triangular matrix\n\n\n          if (j < rows) {\n            // L\n            ldata[i][j] = 0;\n          }\n\n          continue;\n        } // diagonal value\n\n\n        if (i === j) {\n          // check row exists in upper triangular matrix\n          if (i < columns) {\n            // U\n            udata[i][j] = data[i][j];\n          } // check column exists in lower triangular matrix\n\n\n          if (j < rows) {\n            // L\n            ldata[i][j] = 1;\n          }\n\n          continue;\n        } // check row exists in upper triangular matrix\n\n\n        if (i < columns) {\n          // U\n          udata[i][j] = 0;\n        } // check column exists in lower triangular matrix\n\n\n        if (j < rows) {\n          // L\n          ldata[i][j] = data[i][j];\n        }\n      }\n    } // l matrix\n\n\n    var l = new DenseMatrix({\n      data: ldata,\n      size: lsize\n    }); // u matrix\n\n    var u = new DenseMatrix({\n      data: udata,\n      size: usize\n    }); // p vector\n\n    var pv = [];\n\n    for (i = 0, n = p.length; i < n; i++) {\n      pv[p[i]] = i;\n    } // return matrices\n\n\n    return {\n      L: l,\n      U: u,\n      p: pv,\n      toString: function toString() {\n        return 'L: ' + this.L.toString() + '\\nU: ' + this.U.toString() + '\\nP: ' + this.p;\n      }\n    };\n  }\n\n  function _sparseLUP(m) {\n    // rows & columns\n    var rows = m._size[0];\n    var columns = m._size[1]; // minimum rows and columns\n\n    var n = Math.min(rows, columns); // matrix arrays (will not be modified, thanks to permutation vector)\n\n    var values = m._values;\n    var index = m._index;\n    var ptr = m._ptr; // l matrix arrays\n\n    var lvalues = [];\n    var lindex = [];\n    var lptr = [];\n    var lsize = [rows, n]; // u matrix arrays\n\n    var uvalues = [];\n    var uindex = [];\n    var uptr = [];\n    var usize = [n, columns]; // vars\n\n    var i, j, k; // permutation vectors, (current index -> original index) and (original index -> current index)\n\n    var pvCo = [];\n    var pvOc = [];\n\n    for (i = 0; i < rows; i++) {\n      pvCo[i] = i;\n      pvOc[i] = i;\n    } // swap indices in permutation vectors (condition x < y)!\n\n\n    var swapIndeces = function swapIndeces(x, y) {\n      // find pv indeces getting data from x and y\n      var kx = pvOc[x];\n      var ky = pvOc[y]; // update permutation vector current -> original\n\n      pvCo[kx] = y;\n      pvCo[ky] = x; // update permutation vector original -> current\n\n      pvOc[x] = ky;\n      pvOc[y] = kx;\n    }; // loop columns\n\n\n    var _loop = function _loop() {\n      // sparse accumulator\n      var spa = new Spa(); // check lower triangular matrix has a value @ column j\n\n      if (j < rows) {\n        // update ptr\n        lptr.push(lvalues.length); // first value in j column for lower triangular matrix\n\n        lvalues.push(1);\n        lindex.push(j);\n      } // update ptr\n\n\n      uptr.push(uvalues.length); // k0 <= k < k1 where k0 = _ptr[j] && k1 = _ptr[j+1]\n\n      var k0 = ptr[j];\n      var k1 = ptr[j + 1]; // copy column j into sparse accumulator\n\n      for (k = k0; k < k1; k++) {\n        // row\n        i = index[k]; // copy column values into sparse accumulator (use permutation vector)\n\n        spa.set(pvCo[i], values[k]);\n      } // skip first column in upper triangular matrix\n\n\n      if (j > 0) {\n        // loop rows in column j (above diagonal)\n        spa.forEach(0, j - 1, function (k, vkj) {\n          // loop rows in column k (L)\n          SparseMatrix._forEachRow(k, lvalues, lindex, lptr, function (i, vik) {\n            // check row is below k\n            if (i > k) {\n              // update spa value\n              spa.accumulate(i, unaryMinus(multiplyScalar(vik, vkj)));\n            }\n          });\n        });\n      } // row with larger value in spa, row >= j\n\n\n      var pi = j;\n      var vjj = spa.get(j);\n      var pabsv = abs(vjj); // loop values in spa (order by row, below diagonal)\n\n      spa.forEach(j + 1, rows - 1, function (x, v) {\n        // absolute value\n        var absv = abs(v); // value is greater than pivote value\n\n        if (larger(absv, pabsv)) {\n          // store row\n          pi = x; // update max value\n\n          pabsv = absv; // value @ [j, j]\n\n          vjj = v;\n        }\n      }); // swap rows (j <-> pi)\n\n      if (j !== pi) {\n        // swap values j <-> pi in L\n        SparseMatrix._swapRows(j, pi, lsize[1], lvalues, lindex, lptr); // swap values j <-> pi in U\n\n\n        SparseMatrix._swapRows(j, pi, usize[1], uvalues, uindex, uptr); // swap values in spa\n\n\n        spa.swap(j, pi); // update permutation vector (swap values @ j, pi)\n\n        swapIndeces(j, pi);\n      } // loop values in spa (order by row)\n\n\n      spa.forEach(0, rows - 1, function (x, v) {\n        // check we are above diagonal\n        if (x <= j) {\n          // update upper triangular matrix\n          uvalues.push(v);\n          uindex.push(x);\n        } else {\n          // update value\n          v = divideScalar(v, vjj); // check value is non zero\n\n          if (!equalScalar(v, 0)) {\n            // update lower triangular matrix\n            lvalues.push(v);\n            lindex.push(x);\n          }\n        }\n      });\n    };\n\n    for (j = 0; j < columns; j++) {\n      _loop();\n    } // update ptrs\n\n\n    uptr.push(uvalues.length);\n    lptr.push(lvalues.length); // return matrices\n\n    return {\n      L: new SparseMatrix({\n        values: lvalues,\n        index: lindex,\n        ptr: lptr,\n        size: lsize\n      }),\n      U: new SparseMatrix({\n        values: uvalues,\n        index: uindex,\n        ptr: uptr,\n        size: usize\n      }),\n      p: pvCo,\n      toString: function toString() {\n        return 'L: ' + this.L.toString() + '\\nU: ' + this.U.toString() + '\\nP: ' + this.p;\n      }\n    };\n  }\n});","map":{"version":3,"sources":["C:/Users/amase/Desktop/open_dsa/openDSA_dashboard/project/node_modules/mathjs/lib/esm/function/algebra/decomposition/lup.js"],"names":["clone","factory","name","dependencies","createLup","_ref","typed","matrix","abs","addScalar","divideScalar","multiplyScalar","subtract","larger","equalScalar","unaryMinus","DenseMatrix","SparseMatrix","Spa","m","_denseLUP","_sparseLUP","Array","a","r","L","valueOf","U","p","rows","_size","columns","n","Math","min","data","_data","ldata","lsize","udata","usize","i","j","k","s","pi","pabsv","vjj","v","absv","_swapRows","vij","l","size","u","pv","length","toString","values","_values","index","_index","ptr","_ptr","lvalues","lindex","lptr","uvalues","uindex","uptr","pvCo","pvOc","swapIndeces","x","y","kx","ky","_loop","spa","push","k0","k1","set","forEach","vkj","_forEachRow","vik","accumulate","get","swap"],"mappings":"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","sourcesContent":["import { clone } from '../../../utils/object.js';\r\nimport { factory } from '../../../utils/factory.js';\r\nvar name = 'lup';\r\nvar dependencies = ['typed', 'matrix', 'abs', 'addScalar', 'divideScalar', 'multiplyScalar', 'subtract', 'larger', 'equalScalar', 'unaryMinus', 'DenseMatrix', 'SparseMatrix', 'Spa'];\r\nexport var createLup = /* #__PURE__ */factory(name, dependencies, _ref => {\r\n  var {\r\n    typed,\r\n    matrix,\r\n    abs,\r\n    addScalar,\r\n    divideScalar,\r\n    multiplyScalar,\r\n    subtract,\r\n    larger,\r\n    equalScalar,\r\n    unaryMinus,\r\n    DenseMatrix,\r\n    SparseMatrix,\r\n    Spa\r\n  } = _ref;\r\n  /**\r\n   * Calculate the Matrix LU decomposition with partial pivoting. Matrix `A` is decomposed in two matrices (`L`, `U`) and a\r\n   * row permutation vector `p` where `A[p,:] = L * U`\r\n   *\r\n   * Syntax:\r\n   *\r\n   *    math.lup(A)\r\n   *\r\n   * Example:\r\n   *\r\n   *    const m = [[2, 1], [1, 4]]\r\n   *    const r = math.lup(m)\r\n   *    // r = {\r\n   *    //   L: [[1, 0], [0.5, 1]],\r\n   *    //   U: [[2, 1], [0, 3.5]],\r\n   *    //   P: [0, 1]\r\n   *    // }\r\n   *\r\n   * See also:\r\n   *\r\n   *    slu, lsolve, lusolve, usolve\r\n   *\r\n   * @param {Matrix | Array} A    A two dimensional matrix or array for which to get the LUP decomposition.\r\n   *\r\n   * @return {{L: Array | Matrix, U: Array | Matrix, P: Array.<number>}} The lower triangular matrix, the upper triangular matrix and the permutation matrix.\r\n   */\r\n  return typed(name, {\r\n    DenseMatrix: function DenseMatrix(m) {\r\n      return _denseLUP(m);\r\n    },\r\n    SparseMatrix: function SparseMatrix(m) {\r\n      return _sparseLUP(m);\r\n    },\r\n    Array: function Array(a) {\r\n      // create dense matrix from array\r\n      var m = matrix(a);\r\n      // lup, use matrix implementation\r\n      var r = _denseLUP(m);\r\n      // result\r\n      return {\r\n        L: r.L.valueOf(),\r\n        U: r.U.valueOf(),\r\n        p: r.p\r\n      };\r\n    }\r\n  });\r\n  function _denseLUP(m) {\r\n    // rows & columns\r\n    var rows = m._size[0];\r\n    var columns = m._size[1];\r\n    // minimum rows and columns\r\n    var n = Math.min(rows, columns);\r\n    // matrix array, clone original data\r\n    var data = clone(m._data);\r\n    // l matrix arrays\r\n    var ldata = [];\r\n    var lsize = [rows, n];\r\n    // u matrix arrays\r\n    var udata = [];\r\n    var usize = [n, columns];\r\n    // vars\r\n    var i, j, k;\r\n    // permutation vector\r\n    var p = [];\r\n    for (i = 0; i < rows; i++) {\r\n      p[i] = i;\r\n    }\r\n    // loop columns\r\n    for (j = 0; j < columns; j++) {\r\n      // skip first column in upper triangular matrix\r\n      if (j > 0) {\r\n        // loop rows\r\n        for (i = 0; i < rows; i++) {\r\n          // min i,j\r\n          var min = Math.min(i, j);\r\n          // v[i, j]\r\n          var s = 0;\r\n          // loop up to min\r\n          for (k = 0; k < min; k++) {\r\n            // s = l[i, k] - data[k, j]\r\n            s = addScalar(s, multiplyScalar(data[i][k], data[k][j]));\r\n          }\r\n          data[i][j] = subtract(data[i][j], s);\r\n        }\r\n      }\r\n      // row with larger value in cvector, row >= j\r\n      var pi = j;\r\n      var pabsv = 0;\r\n      var vjj = 0;\r\n      // loop rows\r\n      for (i = j; i < rows; i++) {\r\n        // data @ i, j\r\n        var v = data[i][j];\r\n        // absolute value\r\n        var absv = abs(v);\r\n        // value is greater than pivote value\r\n        if (larger(absv, pabsv)) {\r\n          // store row\r\n          pi = i;\r\n          // update max value\r\n          pabsv = absv;\r\n          // value @ [j, j]\r\n          vjj = v;\r\n        }\r\n      }\r\n      // swap rows (j <-> pi)\r\n      if (j !== pi) {\r\n        // swap values j <-> pi in p\r\n        p[j] = [p[pi], p[pi] = p[j]][0];\r\n        // swap j <-> pi in data\r\n        DenseMatrix._swapRows(j, pi, data);\r\n      }\r\n      // check column is in lower triangular matrix\r\n      if (j < rows) {\r\n        // loop rows (lower triangular matrix)\r\n        for (i = j + 1; i < rows; i++) {\r\n          // value @ i, j\r\n          var vij = data[i][j];\r\n          if (!equalScalar(vij, 0)) {\r\n            // update data\r\n            data[i][j] = divideScalar(data[i][j], vjj);\r\n          }\r\n        }\r\n      }\r\n    }\r\n    // loop columns\r\n    for (j = 0; j < columns; j++) {\r\n      // loop rows\r\n      for (i = 0; i < rows; i++) {\r\n        // initialize row in arrays\r\n        if (j === 0) {\r\n          // check row exists in upper triangular matrix\r\n          if (i < columns) {\r\n            // U\r\n            udata[i] = [];\r\n          }\r\n          // L\r\n          ldata[i] = [];\r\n        }\r\n        // check we are in the upper triangular matrix\r\n        if (i < j) {\r\n          // check row exists in upper triangular matrix\r\n          if (i < columns) {\r\n            // U\r\n            udata[i][j] = data[i][j];\r\n          }\r\n          // check column exists in lower triangular matrix\r\n          if (j < rows) {\r\n            // L\r\n            ldata[i][j] = 0;\r\n          }\r\n          continue;\r\n        }\r\n        // diagonal value\r\n        if (i === j) {\r\n          // check row exists in upper triangular matrix\r\n          if (i < columns) {\r\n            // U\r\n            udata[i][j] = data[i][j];\r\n          }\r\n          // check column exists in lower triangular matrix\r\n          if (j < rows) {\r\n            // L\r\n            ldata[i][j] = 1;\r\n          }\r\n          continue;\r\n        }\r\n        // check row exists in upper triangular matrix\r\n        if (i < columns) {\r\n          // U\r\n          udata[i][j] = 0;\r\n        }\r\n        // check column exists in lower triangular matrix\r\n        if (j < rows) {\r\n          // L\r\n          ldata[i][j] = data[i][j];\r\n        }\r\n      }\r\n    }\r\n    // l matrix\r\n    var l = new DenseMatrix({\r\n      data: ldata,\r\n      size: lsize\r\n    });\r\n    // u matrix\r\n    var u = new DenseMatrix({\r\n      data: udata,\r\n      size: usize\r\n    });\r\n    // p vector\r\n    var pv = [];\r\n    for (i = 0, n = p.length; i < n; i++) {\r\n      pv[p[i]] = i;\r\n    }\r\n    // return matrices\r\n    return {\r\n      L: l,\r\n      U: u,\r\n      p: pv,\r\n      toString: function toString() {\r\n        return 'L: ' + this.L.toString() + '\\nU: ' + this.U.toString() + '\\nP: ' + this.p;\r\n      }\r\n    };\r\n  }\r\n  function _sparseLUP(m) {\r\n    // rows & columns\r\n    var rows = m._size[0];\r\n    var columns = m._size[1];\r\n    // minimum rows and columns\r\n    var n = Math.min(rows, columns);\r\n    // matrix arrays (will not be modified, thanks to permutation vector)\r\n    var values = m._values;\r\n    var index = m._index;\r\n    var ptr = m._ptr;\r\n    // l matrix arrays\r\n    var lvalues = [];\r\n    var lindex = [];\r\n    var lptr = [];\r\n    var lsize = [rows, n];\r\n    // u matrix arrays\r\n    var uvalues = [];\r\n    var uindex = [];\r\n    var uptr = [];\r\n    var usize = [n, columns];\r\n    // vars\r\n    var i, j, k;\r\n    // permutation vectors, (current index -> original index) and (original index -> current index)\r\n    var pvCo = [];\r\n    var pvOc = [];\r\n    for (i = 0; i < rows; i++) {\r\n      pvCo[i] = i;\r\n      pvOc[i] = i;\r\n    }\r\n    // swap indices in permutation vectors (condition x < y)!\r\n    var swapIndeces = function swapIndeces(x, y) {\r\n      // find pv indeces getting data from x and y\r\n      var kx = pvOc[x];\r\n      var ky = pvOc[y];\r\n      // update permutation vector current -> original\r\n      pvCo[kx] = y;\r\n      pvCo[ky] = x;\r\n      // update permutation vector original -> current\r\n      pvOc[x] = ky;\r\n      pvOc[y] = kx;\r\n    };\r\n    // loop columns\r\n    var _loop = function _loop() {\r\n      // sparse accumulator\r\n      var spa = new Spa();\r\n      // check lower triangular matrix has a value @ column j\r\n      if (j < rows) {\r\n        // update ptr\r\n        lptr.push(lvalues.length);\r\n        // first value in j column for lower triangular matrix\r\n        lvalues.push(1);\r\n        lindex.push(j);\r\n      }\r\n      // update ptr\r\n      uptr.push(uvalues.length);\r\n      // k0 <= k < k1 where k0 = _ptr[j] && k1 = _ptr[j+1]\r\n      var k0 = ptr[j];\r\n      var k1 = ptr[j + 1];\r\n      // copy column j into sparse accumulator\r\n      for (k = k0; k < k1; k++) {\r\n        // row\r\n        i = index[k];\r\n        // copy column values into sparse accumulator (use permutation vector)\r\n        spa.set(pvCo[i], values[k]);\r\n      }\r\n      // skip first column in upper triangular matrix\r\n      if (j > 0) {\r\n        // loop rows in column j (above diagonal)\r\n        spa.forEach(0, j - 1, function (k, vkj) {\r\n          // loop rows in column k (L)\r\n          SparseMatrix._forEachRow(k, lvalues, lindex, lptr, function (i, vik) {\r\n            // check row is below k\r\n            if (i > k) {\r\n              // update spa value\r\n              spa.accumulate(i, unaryMinus(multiplyScalar(vik, vkj)));\r\n            }\r\n          });\r\n        });\r\n      }\r\n      // row with larger value in spa, row >= j\r\n      var pi = j;\r\n      var vjj = spa.get(j);\r\n      var pabsv = abs(vjj);\r\n      // loop values in spa (order by row, below diagonal)\r\n      spa.forEach(j + 1, rows - 1, function (x, v) {\r\n        // absolute value\r\n        var absv = abs(v);\r\n        // value is greater than pivote value\r\n        if (larger(absv, pabsv)) {\r\n          // store row\r\n          pi = x;\r\n          // update max value\r\n          pabsv = absv;\r\n          // value @ [j, j]\r\n          vjj = v;\r\n        }\r\n      });\r\n      // swap rows (j <-> pi)\r\n      if (j !== pi) {\r\n        // swap values j <-> pi in L\r\n        SparseMatrix._swapRows(j, pi, lsize[1], lvalues, lindex, lptr);\r\n        // swap values j <-> pi in U\r\n        SparseMatrix._swapRows(j, pi, usize[1], uvalues, uindex, uptr);\r\n        // swap values in spa\r\n        spa.swap(j, pi);\r\n        // update permutation vector (swap values @ j, pi)\r\n        swapIndeces(j, pi);\r\n      }\r\n      // loop values in spa (order by row)\r\n      spa.forEach(0, rows - 1, function (x, v) {\r\n        // check we are above diagonal\r\n        if (x <= j) {\r\n          // update upper triangular matrix\r\n          uvalues.push(v);\r\n          uindex.push(x);\r\n        } else {\r\n          // update value\r\n          v = divideScalar(v, vjj);\r\n          // check value is non zero\r\n          if (!equalScalar(v, 0)) {\r\n            // update lower triangular matrix\r\n            lvalues.push(v);\r\n            lindex.push(x);\r\n          }\r\n        }\r\n      });\r\n    };\r\n    for (j = 0; j < columns; j++) {\r\n      _loop();\r\n    }\r\n    // update ptrs\r\n    uptr.push(uvalues.length);\r\n    lptr.push(lvalues.length);\r\n\r\n    // return matrices\r\n    return {\r\n      L: new SparseMatrix({\r\n        values: lvalues,\r\n        index: lindex,\r\n        ptr: lptr,\r\n        size: lsize\r\n      }),\r\n      U: new SparseMatrix({\r\n        values: uvalues,\r\n        index: uindex,\r\n        ptr: uptr,\r\n        size: usize\r\n      }),\r\n      p: pvCo,\r\n      toString: function toString() {\r\n        return 'L: ' + this.L.toString() + '\\nU: ' + this.U.toString() + '\\nP: ' + this.p;\r\n      }\r\n    };\r\n  }\r\n});"]},"metadata":{},"sourceType":"module"}