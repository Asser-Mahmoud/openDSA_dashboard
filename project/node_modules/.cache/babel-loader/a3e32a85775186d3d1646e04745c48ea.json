{"ast":null,"code":"import { escape } from '../../utils/string.js';\nimport { getSafeProperty } from '../../utils/customs.js';\nimport { factory } from '../../utils/factory.js';\nimport { toSymbol } from '../../utils/latex.js';\nvar name = 'SymbolNode';\nvar dependencies = ['math', '?Unit', 'Node'];\nexport var createSymbolNode = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    math,\n    Unit,\n    Node\n  } = _ref;\n  /**\r\n   * Check whether some name is a valueless unit like \"inch\".\r\n   * @param {string} name\r\n   * @return {boolean}\r\n   */\n\n  function isValuelessUnit(name) {\n    return Unit ? Unit.isValuelessUnit(name) : false;\n  }\n\n  class SymbolNode extends Node {\n    /**\r\n     * @constructor SymbolNode\r\n     * @extends {Node}\r\n     * A symbol node can hold and resolve a symbol\r\n     * @param {string} name\r\n     * @extends {Node}\r\n     */\n    constructor(name) {\n      super(); // validate input\n\n      if (typeof name !== 'string') {\n        throw new TypeError('String expected for parameter \"name\"');\n      }\n\n      this.name = name;\n    }\n\n    get type() {\n      return 'SymbolNode';\n    }\n\n    get isSymbolNode() {\n      return true;\n    }\n    /**\r\n     * Compile a node into a JavaScript function.\r\n     * This basically pre-calculates as much as possible and only leaves open\r\n     * calculations which depend on a dynamic scope with variables.\r\n     * @param {Object} math     Math.js namespace with functions and constants.\r\n     * @param {Object} argNames An object with argument names as key and `true`\r\n     *                          as value. Used in the SymbolNode to optimize\r\n     *                          for arguments from user assigned functions\r\n     *                          (see FunctionAssignmentNode) or special symbols\r\n     *                          like `end` (see IndexNode).\r\n     * @return {function} Returns a function which can be called like:\r\n     *                        evalNode(scope: Object, args: Object, context: *)\r\n     */\n\n\n    _compile(math, argNames) {\n      var name = this.name;\n\n      if (argNames[name] === true) {\n        // this is a FunctionAssignment argument\n        // (like an x when inside the expression of a function\n        // assignment `f(x) = ...`)\n        return function (scope, args, context) {\n          return args[name];\n        };\n      } else if (name in math) {\n        return function (scope, args, context) {\n          return scope.has(name) ? scope.get(name) : getSafeProperty(math, name);\n        };\n      } else {\n        var isUnit = isValuelessUnit(name);\n        return function (scope, args, context) {\n          return scope.has(name) ? scope.get(name) : isUnit ? new Unit(null, name) : SymbolNode.onUndefinedSymbol(name);\n        };\n      }\n    }\n    /**\r\n     * Execute a callback for each of the child nodes of this node\r\n     * @param {function(child: Node, path: string, parent: Node)} callback\r\n     */\n\n\n    forEach(callback) {// nothing to do, we don't have any children\n    }\n    /**\r\n     * Create a new SymbolNode with children produced by the given callback.\r\n     * Trivial since a SymbolNode has no children\r\n     * @param {function(child: Node, path: string, parent: Node) : Node} callback\r\n     * @returns {SymbolNode} Returns a clone of the node\r\n     */\n\n\n    map(callback) {\n      return this.clone();\n    }\n    /**\r\n     * Throws an error 'Undefined symbol {name}'\r\n     * @param {string} name\r\n     */\n\n\n    static onUndefinedSymbol(name) {\n      throw new Error('Undefined symbol ' + name);\n    }\n    /**\r\n     * Create a clone of this node, a shallow copy\r\n     * @return {SymbolNode}\r\n     */\n\n\n    clone() {\n      return new SymbolNode(this.name);\n    }\n    /**\r\n     * Get string representation\r\n     * @param {Object} options\r\n     * @return {string} str\r\n     * @override\r\n     */\n\n\n    _toString(options) {\n      return this.name;\n    }\n    /**\r\n     * Get HTML representation\r\n     * @param {Object} options\r\n     * @return {string} str\r\n     * @override\r\n     */\n\n\n    toHTML(options) {\n      var name = escape(this.name);\n\n      if (name === 'true' || name === 'false') {\n        return '<span class=\"math-symbol math-boolean\">' + name + '</span>';\n      } else if (name === 'i') {\n        return '<span class=\"math-symbol math-imaginary-symbol\">' + name + '</span>';\n      } else if (name === 'Infinity') {\n        return '<span class=\"math-symbol math-infinity-symbol\">' + name + '</span>';\n      } else if (name === 'NaN') {\n        return '<span class=\"math-symbol math-nan-symbol\">' + name + '</span>';\n      } else if (name === 'null') {\n        return '<span class=\"math-symbol math-null-symbol\">' + name + '</span>';\n      } else if (name === 'undefined') {\n        return '<span class=\"math-symbol math-undefined-symbol\">' + name + '</span>';\n      }\n\n      return '<span class=\"math-symbol\">' + name + '</span>';\n    }\n    /**\r\n     * Get a JSON representation of the node\r\n     * @returns {Object}\r\n     */\n\n\n    toJSON() {\n      return {\n        mathjs: 'SymbolNode',\n        name: this.name\n      };\n    }\n    /**\r\n     * Instantiate a SymbolNode from its JSON representation\r\n     * @param {Object} json  An object structured like\r\n     *                       `{\"mathjs\": \"SymbolNode\", name: \"x\"}`,\r\n     *                       where mathjs is optional\r\n     * @returns {SymbolNode}\r\n     */\n\n\n    static fromJSON(json) {\n      return new SymbolNode(json.name);\n    }\n    /**\r\n     * Get LaTeX representation\r\n     * @param {Object} options\r\n     * @return {string} str\r\n     * @override\r\n     */\n\n\n    _toTex(options) {\n      var isUnit = false;\n\n      if (typeof math[this.name] === 'undefined' && isValuelessUnit(this.name)) {\n        isUnit = true;\n      }\n\n      var symbol = toSymbol(this.name, isUnit);\n\n      if (symbol[0] === '\\\\') {\n        // no space needed if the symbol starts with '\\'\n        return symbol;\n      } // the space prevents symbols from breaking stuff like '\\cdot'\n      // if it's written right before the symbol\n\n\n      return ' ' + symbol;\n    }\n\n  }\n\n  return SymbolNode;\n}, {\n  isClass: true,\n  isNode: true\n});","map":{"version":3,"sources":["C:/Users/amase/Desktop/open_dsa/openDSA_dashboard/project/node_modules/mathjs/lib/esm/expression/node/SymbolNode.js"],"names":["escape","getSafeProperty","factory","toSymbol","name","dependencies","createSymbolNode","_ref","math","Unit","Node","isValuelessUnit","SymbolNode","constructor","TypeError","type","isSymbolNode","_compile","argNames","scope","args","context","has","get","isUnit","onUndefinedSymbol","forEach","callback","map","clone","Error","_toString","options","toHTML","toJSON","mathjs","fromJSON","json","_toTex","symbol","isClass","isNode"],"mappings":"AAAA,SAASA,MAAT,QAAuB,uBAAvB;AACA,SAASC,eAAT,QAAgC,wBAAhC;AACA,SAASC,OAAT,QAAwB,wBAAxB;AACA,SAASC,QAAT,QAAyB,sBAAzB;AACA,IAAIC,IAAI,GAAG,YAAX;AACA,IAAIC,YAAY,GAAG,CAAC,MAAD,EAAS,OAAT,EAAkB,MAAlB,CAAnB;AACA,OAAO,IAAIC,gBAAgB,GAAG,eAAeJ,OAAO,CAACE,IAAD,EAAOC,YAAP,EAAqBE,IAAI,IAAI;AAC/E,MAAI;AACFC,IAAAA,IADE;AAEFC,IAAAA,IAFE;AAGFC,IAAAA;AAHE,MAIAH,IAJJ;AAKA;AACF;AACA;AACA;AACA;;AACE,WAASI,eAAT,CAAyBP,IAAzB,EAA+B;AAC7B,WAAOK,IAAI,GAAGA,IAAI,CAACE,eAAL,CAAqBP,IAArB,CAAH,GAAgC,KAA3C;AACD;;AACD,QAAMQ,UAAN,SAAyBF,IAAzB,CAA8B;AAC5B;AACJ;AACA;AACA;AACA;AACA;AACA;AACIG,IAAAA,WAAW,CAACT,IAAD,EAAO;AAChB,cADgB,CAEhB;;AACA,UAAI,OAAOA,IAAP,KAAgB,QAApB,EAA8B;AAC5B,cAAM,IAAIU,SAAJ,CAAc,sCAAd,CAAN;AACD;;AACD,WAAKV,IAAL,GAAYA,IAAZ;AACD;;AACO,QAAJW,IAAI,GAAG;AACT,aAAO,YAAP;AACD;;AACe,QAAZC,YAAY,GAAG;AACjB,aAAO,IAAP;AACD;AAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACIC,IAAAA,QAAQ,CAACT,IAAD,EAAOU,QAAP,EAAiB;AACvB,UAAId,IAAI,GAAG,KAAKA,IAAhB;;AACA,UAAIc,QAAQ,CAACd,IAAD,CAAR,KAAmB,IAAvB,EAA6B;AAC3B;AACA;AACA;AACA,eAAO,UAAUe,KAAV,EAAiBC,IAAjB,EAAuBC,OAAvB,EAAgC;AACrC,iBAAOD,IAAI,CAAChB,IAAD,CAAX;AACD,SAFD;AAGD,OAPD,MAOO,IAAIA,IAAI,IAAII,IAAZ,EAAkB;AACvB,eAAO,UAAUW,KAAV,EAAiBC,IAAjB,EAAuBC,OAAvB,EAAgC;AACrC,iBAAOF,KAAK,CAACG,GAAN,CAAUlB,IAAV,IAAkBe,KAAK,CAACI,GAAN,CAAUnB,IAAV,CAAlB,GAAoCH,eAAe,CAACO,IAAD,EAAOJ,IAAP,CAA1D;AACD,SAFD;AAGD,OAJM,MAIA;AACL,YAAIoB,MAAM,GAAGb,eAAe,CAACP,IAAD,CAA5B;AACA,eAAO,UAAUe,KAAV,EAAiBC,IAAjB,EAAuBC,OAAvB,EAAgC;AACrC,iBAAOF,KAAK,CAACG,GAAN,CAAUlB,IAAV,IAAkBe,KAAK,CAACI,GAAN,CAAUnB,IAAV,CAAlB,GAAoCoB,MAAM,GAAG,IAAIf,IAAJ,CAAS,IAAT,EAAeL,IAAf,CAAH,GAA0BQ,UAAU,CAACa,iBAAX,CAA6BrB,IAA7B,CAA3E;AACD,SAFD;AAGD;AACF;AAED;AACJ;AACA;AACA;;;AACIsB,IAAAA,OAAO,CAACC,QAAD,EAAW,CAChB;AACD;AAED;AACJ;AACA;AACA;AACA;AACA;;;AACIC,IAAAA,GAAG,CAACD,QAAD,EAAW;AACZ,aAAO,KAAKE,KAAL,EAAP;AACD;AAED;AACJ;AACA;AACA;;;AAC4B,WAAjBJ,iBAAiB,CAACrB,IAAD,EAAO;AAC7B,YAAM,IAAI0B,KAAJ,CAAU,sBAAsB1B,IAAhC,CAAN;AACD;AAED;AACJ;AACA;AACA;;;AACIyB,IAAAA,KAAK,GAAG;AACN,aAAO,IAAIjB,UAAJ,CAAe,KAAKR,IAApB,CAAP;AACD;AAED;AACJ;AACA;AACA;AACA;AACA;;;AACI2B,IAAAA,SAAS,CAACC,OAAD,EAAU;AACjB,aAAO,KAAK5B,IAAZ;AACD;AAED;AACJ;AACA;AACA;AACA;AACA;;;AACI6B,IAAAA,MAAM,CAACD,OAAD,EAAU;AACd,UAAI5B,IAAI,GAAGJ,MAAM,CAAC,KAAKI,IAAN,CAAjB;;AACA,UAAIA,IAAI,KAAK,MAAT,IAAmBA,IAAI,KAAK,OAAhC,EAAyC;AACvC,eAAO,4CAA4CA,IAA5C,GAAmD,SAA1D;AACD,OAFD,MAEO,IAAIA,IAAI,KAAK,GAAb,EAAkB;AACvB,eAAO,qDAAqDA,IAArD,GAA4D,SAAnE;AACD,OAFM,MAEA,IAAIA,IAAI,KAAK,UAAb,EAAyB;AAC9B,eAAO,oDAAoDA,IAApD,GAA2D,SAAlE;AACD,OAFM,MAEA,IAAIA,IAAI,KAAK,KAAb,EAAoB;AACzB,eAAO,+CAA+CA,IAA/C,GAAsD,SAA7D;AACD,OAFM,MAEA,IAAIA,IAAI,KAAK,MAAb,EAAqB;AAC1B,eAAO,gDAAgDA,IAAhD,GAAuD,SAA9D;AACD,OAFM,MAEA,IAAIA,IAAI,KAAK,WAAb,EAA0B;AAC/B,eAAO,qDAAqDA,IAArD,GAA4D,SAAnE;AACD;;AACD,aAAO,+BAA+BA,IAA/B,GAAsC,SAA7C;AACD;AAED;AACJ;AACA;AACA;;;AACI8B,IAAAA,MAAM,GAAG;AACP,aAAO;AACLC,QAAAA,MAAM,EAAE,YADH;AAEL/B,QAAAA,IAAI,EAAE,KAAKA;AAFN,OAAP;AAID;AAED;AACJ;AACA;AACA;AACA;AACA;AACA;;;AACmB,WAARgC,QAAQ,CAACC,IAAD,EAAO;AACpB,aAAO,IAAIzB,UAAJ,CAAeyB,IAAI,CAACjC,IAApB,CAAP;AACD;AAED;AACJ;AACA;AACA;AACA;AACA;;;AACIkC,IAAAA,MAAM,CAACN,OAAD,EAAU;AACd,UAAIR,MAAM,GAAG,KAAb;;AACA,UAAI,OAAOhB,IAAI,CAAC,KAAKJ,IAAN,CAAX,KAA2B,WAA3B,IAA0CO,eAAe,CAAC,KAAKP,IAAN,CAA7D,EAA0E;AACxEoB,QAAAA,MAAM,GAAG,IAAT;AACD;;AACD,UAAIe,MAAM,GAAGpC,QAAQ,CAAC,KAAKC,IAAN,EAAYoB,MAAZ,CAArB;;AACA,UAAIe,MAAM,CAAC,CAAD,CAAN,KAAc,IAAlB,EAAwB;AACtB;AACA,eAAOA,MAAP;AACD,OATa,CAUd;AACA;;;AACA,aAAO,MAAMA,MAAb;AACD;;AAtK2B;;AAwK9B,SAAO3B,UAAP;AACD,CAvLmD,EAuLjD;AACD4B,EAAAA,OAAO,EAAE,IADR;AAEDC,EAAAA,MAAM,EAAE;AAFP,CAvLiD,CAA7C","sourcesContent":["import { escape } from '../../utils/string.js';\r\nimport { getSafeProperty } from '../../utils/customs.js';\r\nimport { factory } from '../../utils/factory.js';\r\nimport { toSymbol } from '../../utils/latex.js';\r\nvar name = 'SymbolNode';\r\nvar dependencies = ['math', '?Unit', 'Node'];\r\nexport var createSymbolNode = /* #__PURE__ */factory(name, dependencies, _ref => {\r\n  var {\r\n    math,\r\n    Unit,\r\n    Node\r\n  } = _ref;\r\n  /**\r\n   * Check whether some name is a valueless unit like \"inch\".\r\n   * @param {string} name\r\n   * @return {boolean}\r\n   */\r\n  function isValuelessUnit(name) {\r\n    return Unit ? Unit.isValuelessUnit(name) : false;\r\n  }\r\n  class SymbolNode extends Node {\r\n    /**\r\n     * @constructor SymbolNode\r\n     * @extends {Node}\r\n     * A symbol node can hold and resolve a symbol\r\n     * @param {string} name\r\n     * @extends {Node}\r\n     */\r\n    constructor(name) {\r\n      super();\r\n      // validate input\r\n      if (typeof name !== 'string') {\r\n        throw new TypeError('String expected for parameter \"name\"');\r\n      }\r\n      this.name = name;\r\n    }\r\n    get type() {\r\n      return 'SymbolNode';\r\n    }\r\n    get isSymbolNode() {\r\n      return true;\r\n    }\r\n\r\n    /**\r\n     * Compile a node into a JavaScript function.\r\n     * This basically pre-calculates as much as possible and only leaves open\r\n     * calculations which depend on a dynamic scope with variables.\r\n     * @param {Object} math     Math.js namespace with functions and constants.\r\n     * @param {Object} argNames An object with argument names as key and `true`\r\n     *                          as value. Used in the SymbolNode to optimize\r\n     *                          for arguments from user assigned functions\r\n     *                          (see FunctionAssignmentNode) or special symbols\r\n     *                          like `end` (see IndexNode).\r\n     * @return {function} Returns a function which can be called like:\r\n     *                        evalNode(scope: Object, args: Object, context: *)\r\n     */\r\n    _compile(math, argNames) {\r\n      var name = this.name;\r\n      if (argNames[name] === true) {\r\n        // this is a FunctionAssignment argument\r\n        // (like an x when inside the expression of a function\r\n        // assignment `f(x) = ...`)\r\n        return function (scope, args, context) {\r\n          return args[name];\r\n        };\r\n      } else if (name in math) {\r\n        return function (scope, args, context) {\r\n          return scope.has(name) ? scope.get(name) : getSafeProperty(math, name);\r\n        };\r\n      } else {\r\n        var isUnit = isValuelessUnit(name);\r\n        return function (scope, args, context) {\r\n          return scope.has(name) ? scope.get(name) : isUnit ? new Unit(null, name) : SymbolNode.onUndefinedSymbol(name);\r\n        };\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Execute a callback for each of the child nodes of this node\r\n     * @param {function(child: Node, path: string, parent: Node)} callback\r\n     */\r\n    forEach(callback) {\r\n      // nothing to do, we don't have any children\r\n    }\r\n\r\n    /**\r\n     * Create a new SymbolNode with children produced by the given callback.\r\n     * Trivial since a SymbolNode has no children\r\n     * @param {function(child: Node, path: string, parent: Node) : Node} callback\r\n     * @returns {SymbolNode} Returns a clone of the node\r\n     */\r\n    map(callback) {\r\n      return this.clone();\r\n    }\r\n\r\n    /**\r\n     * Throws an error 'Undefined symbol {name}'\r\n     * @param {string} name\r\n     */\r\n    static onUndefinedSymbol(name) {\r\n      throw new Error('Undefined symbol ' + name);\r\n    }\r\n\r\n    /**\r\n     * Create a clone of this node, a shallow copy\r\n     * @return {SymbolNode}\r\n     */\r\n    clone() {\r\n      return new SymbolNode(this.name);\r\n    }\r\n\r\n    /**\r\n     * Get string representation\r\n     * @param {Object} options\r\n     * @return {string} str\r\n     * @override\r\n     */\r\n    _toString(options) {\r\n      return this.name;\r\n    }\r\n\r\n    /**\r\n     * Get HTML representation\r\n     * @param {Object} options\r\n     * @return {string} str\r\n     * @override\r\n     */\r\n    toHTML(options) {\r\n      var name = escape(this.name);\r\n      if (name === 'true' || name === 'false') {\r\n        return '<span class=\"math-symbol math-boolean\">' + name + '</span>';\r\n      } else if (name === 'i') {\r\n        return '<span class=\"math-symbol math-imaginary-symbol\">' + name + '</span>';\r\n      } else if (name === 'Infinity') {\r\n        return '<span class=\"math-symbol math-infinity-symbol\">' + name + '</span>';\r\n      } else if (name === 'NaN') {\r\n        return '<span class=\"math-symbol math-nan-symbol\">' + name + '</span>';\r\n      } else if (name === 'null') {\r\n        return '<span class=\"math-symbol math-null-symbol\">' + name + '</span>';\r\n      } else if (name === 'undefined') {\r\n        return '<span class=\"math-symbol math-undefined-symbol\">' + name + '</span>';\r\n      }\r\n      return '<span class=\"math-symbol\">' + name + '</span>';\r\n    }\r\n\r\n    /**\r\n     * Get a JSON representation of the node\r\n     * @returns {Object}\r\n     */\r\n    toJSON() {\r\n      return {\r\n        mathjs: 'SymbolNode',\r\n        name: this.name\r\n      };\r\n    }\r\n\r\n    /**\r\n     * Instantiate a SymbolNode from its JSON representation\r\n     * @param {Object} json  An object structured like\r\n     *                       `{\"mathjs\": \"SymbolNode\", name: \"x\"}`,\r\n     *                       where mathjs is optional\r\n     * @returns {SymbolNode}\r\n     */\r\n    static fromJSON(json) {\r\n      return new SymbolNode(json.name);\r\n    }\r\n\r\n    /**\r\n     * Get LaTeX representation\r\n     * @param {Object} options\r\n     * @return {string} str\r\n     * @override\r\n     */\r\n    _toTex(options) {\r\n      var isUnit = false;\r\n      if (typeof math[this.name] === 'undefined' && isValuelessUnit(this.name)) {\r\n        isUnit = true;\r\n      }\r\n      var symbol = toSymbol(this.name, isUnit);\r\n      if (symbol[0] === '\\\\') {\r\n        // no space needed if the symbol starts with '\\'\r\n        return symbol;\r\n      }\r\n      // the space prevents symbols from breaking stuff like '\\cdot'\r\n      // if it's written right before the symbol\r\n      return ' ' + symbol;\r\n    }\r\n  }\r\n  return SymbolNode;\r\n}, {\r\n  isClass: true,\r\n  isNode: true\r\n});"]},"metadata":{},"sourceType":"module"}