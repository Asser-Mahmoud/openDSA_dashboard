{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport { isNode, isConstantNode, isOperatorNode, isParenthesisNode } from '../../utils/is.js';\nimport { map } from '../../utils/array.js';\nimport { escape } from '../../utils/string.js';\nimport { getSafeProperty, isSafeMethod } from '../../utils/customs.js';\nimport { getAssociativity, getPrecedence, isAssociativeWith, properties } from '../operators.js';\nimport { latexOperators } from '../../utils/latex.js';\nimport { factory } from '../../utils/factory.js';\nvar name = 'OperatorNode';\nvar dependencies = ['Node'];\nexport var createOperatorNode = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    Node\n  } = _ref;\n  /**\r\n   * Returns true if the expression starts with a constant, under\r\n   * the current parenthesization:\r\n   * @param {Node} expression\r\n   * @param {string} parenthesis\r\n   * @return {boolean}\r\n   */\n\n  function startsWithConstant(expr, parenthesis) {\n    var curNode = expr;\n\n    if (parenthesis === 'auto') {\n      while (isParenthesisNode(curNode)) {\n        curNode = curNode.content;\n      }\n    }\n\n    if (isConstantNode(curNode)) return true;\n\n    if (isOperatorNode(curNode)) {\n      return startsWithConstant(curNode.args[0], parenthesis);\n    }\n\n    return false;\n  }\n  /**\r\n   * Calculate which parentheses are necessary. Gets an OperatorNode\r\n   * (which is the root of the tree) and an Array of Nodes\r\n   * (this.args) and returns an array where 'true' means that an argument\r\n   * has to be enclosed in parentheses whereas 'false' means the opposite.\r\n   *\r\n   * @param {OperatorNode} root\r\n   * @param {string} parenthesis\r\n   * @param {Node[]} args\r\n   * @param {boolean} latex\r\n   * @return {boolean[]}\r\n   * @private\r\n   */\n\n\n  function calculateNecessaryParentheses(root, parenthesis, implicit, args, latex) {\n    // precedence of the root OperatorNode\n    var precedence = getPrecedence(root, parenthesis, implicit);\n    var associativity = getAssociativity(root, parenthesis);\n\n    if (parenthesis === 'all' || args.length > 2 && root.getIdentifier() !== 'OperatorNode:add' && root.getIdentifier() !== 'OperatorNode:multiply') {\n      return args.map(function (arg) {\n        switch (arg.getContent().type) {\n          // Nodes that don't need extra parentheses\n          case 'ArrayNode':\n          case 'ConstantNode':\n          case 'SymbolNode':\n          case 'ParenthesisNode':\n            return false;\n\n          default:\n            return true;\n        }\n      });\n    }\n\n    var result;\n\n    switch (args.length) {\n      case 0:\n        result = [];\n        break;\n\n      case 1:\n        // unary operators\n        {\n          // precedence of the operand\n          var operandPrecedence = getPrecedence(args[0], parenthesis, implicit, root); // handle special cases for LaTeX, where some of the parentheses aren't needed\n\n          if (latex && operandPrecedence !== null) {\n            var operandIdentifier;\n            var rootIdentifier;\n\n            if (parenthesis === 'keep') {\n              operandIdentifier = args[0].getIdentifier();\n              rootIdentifier = root.getIdentifier();\n            } else {\n              // Ignore Parenthesis Nodes when not in 'keep' mode\n              operandIdentifier = args[0].getContent().getIdentifier();\n              rootIdentifier = root.getContent().getIdentifier();\n            }\n\n            if (properties[precedence][rootIdentifier].latexLeftParens === false) {\n              result = [false];\n              break;\n            }\n\n            if (properties[operandPrecedence][operandIdentifier].latexParens === false) {\n              result = [false];\n              break;\n            }\n          }\n\n          if (operandPrecedence === null) {\n            // if the operand has no defined precedence, no parens are needed\n            result = [false];\n            break;\n          }\n\n          if (operandPrecedence <= precedence) {\n            // if the operands precedence is lower, parens are needed\n            result = [true];\n            break;\n          } // otherwise, no parens needed\n\n\n          result = [false];\n        }\n        break;\n\n      case 2:\n        // binary operators\n        {\n          var lhsParens; // left hand side needs parenthesis?\n          // precedence of the left hand side\n\n          var lhsPrecedence = getPrecedence(args[0], parenthesis, implicit, root); // is the root node associative with the left hand side\n\n          var assocWithLhs = isAssociativeWith(root, args[0], parenthesis);\n\n          if (lhsPrecedence === null) {\n            // if the left hand side has no defined precedence, no parens are needed\n            // FunctionNode for example\n            lhsParens = false;\n          } else if (lhsPrecedence === precedence && associativity === 'right' && !assocWithLhs) {\n            // In case of equal precedence, if the root node is left associative\n            // parens are **never** necessary for the left hand side.\n            // If it is right associative however, parens are necessary\n            // if the root node isn't associative with the left hand side\n            lhsParens = true;\n          } else if (lhsPrecedence < precedence) {\n            lhsParens = true;\n          } else {\n            lhsParens = false;\n          }\n\n          var rhsParens; // right hand side needs parenthesis?\n          // precedence of the right hand side\n\n          var rhsPrecedence = getPrecedence(args[1], parenthesis, implicit, root); // is the root node associative with the right hand side?\n\n          var assocWithRhs = isAssociativeWith(root, args[1], parenthesis);\n\n          if (rhsPrecedence === null) {\n            // if the right hand side has no defined precedence, no parens are needed\n            // FunctionNode for example\n            rhsParens = false;\n          } else if (rhsPrecedence === precedence && associativity === 'left' && !assocWithRhs) {\n            // In case of equal precedence, if the root node is right associative\n            // parens are **never** necessary for the right hand side.\n            // If it is left associative however, parens are necessary\n            // if the root node isn't associative with the right hand side\n            rhsParens = true;\n          } else if (rhsPrecedence < precedence) {\n            rhsParens = true;\n          } else {\n            rhsParens = false;\n          } // handle special cases for LaTeX, where some of the parentheses aren't needed\n\n\n          if (latex) {\n            var _rootIdentifier;\n\n            var lhsIdentifier;\n            var rhsIdentifier;\n\n            if (parenthesis === 'keep') {\n              _rootIdentifier = root.getIdentifier();\n              lhsIdentifier = root.args[0].getIdentifier();\n              rhsIdentifier = root.args[1].getIdentifier();\n            } else {\n              // Ignore ParenthesisNodes when not in 'keep' mode\n              _rootIdentifier = root.getContent().getIdentifier();\n              lhsIdentifier = root.args[0].getContent().getIdentifier();\n              rhsIdentifier = root.args[1].getContent().getIdentifier();\n            }\n\n            if (lhsPrecedence !== null) {\n              if (properties[precedence][_rootIdentifier].latexLeftParens === false) {\n                lhsParens = false;\n              }\n\n              if (properties[lhsPrecedence][lhsIdentifier].latexParens === false) {\n                lhsParens = false;\n              }\n            }\n\n            if (rhsPrecedence !== null) {\n              if (properties[precedence][_rootIdentifier].latexRightParens === false) {\n                rhsParens = false;\n              }\n\n              if (properties[rhsPrecedence][rhsIdentifier].latexParens === false) {\n                rhsParens = false;\n              }\n            }\n          }\n\n          result = [lhsParens, rhsParens];\n        }\n        break;\n\n      default:\n        if (root.getIdentifier() === 'OperatorNode:add' || root.getIdentifier() === 'OperatorNode:multiply') {\n          result = args.map(function (arg) {\n            var argPrecedence = getPrecedence(arg, parenthesis, implicit, root);\n            var assocWithArg = isAssociativeWith(root, arg, parenthesis);\n            var argAssociativity = getAssociativity(arg, parenthesis);\n\n            if (argPrecedence === null) {\n              // if the argument has no defined precedence, no parens are needed\n              return false;\n            } else if (precedence === argPrecedence && associativity === argAssociativity && !assocWithArg) {\n              return true;\n            } else if (argPrecedence < precedence) {\n              return true;\n            }\n\n            return false;\n          });\n        }\n\n        break;\n    } // Handles an edge case of parentheses with implicit multiplication\n    // of ConstantNode.\n    // In that case, parenthesize ConstantNodes that follow an unparenthesized\n    // expression, even though they normally wouldn't be printed.\n\n\n    if (args.length >= 2 && root.getIdentifier() === 'OperatorNode:multiply' && root.implicit && parenthesis !== 'all' && implicit === 'hide') {\n      for (var i = 1; i < result.length; ++i) {\n        if (startsWithConstant(args[i], parenthesis) && !result[i - 1] && (parenthesis !== 'keep' || !isParenthesisNode(args[i - 1]))) {\n          result[i] = true;\n        }\n      }\n    }\n\n    return result;\n  }\n\n  class OperatorNode extends Node {\n    /**\r\n     * @constructor OperatorNode\r\n     * @extends {Node}\r\n     * An operator with two arguments, like 2+3\r\n     *\r\n     * @param {string} op           Operator name, for example '+'\r\n     * @param {string} fn           Function name, for example 'add'\r\n     * @param {Node[]} args         Operator arguments\r\n     * @param {boolean} [implicit]  Is this an implicit multiplication?\r\n     * @param {boolean} [isPercentage] Is this an percentage Operation?\r\n     */\n    constructor(op, fn, args, implicit, isPercentage) {\n      super(); // validate input\n\n      if (typeof op !== 'string') {\n        throw new TypeError('string expected for parameter \"op\"');\n      }\n\n      if (typeof fn !== 'string') {\n        throw new TypeError('string expected for parameter \"fn\"');\n      }\n\n      if (!Array.isArray(args) || !args.every(isNode)) {\n        throw new TypeError('Array containing Nodes expected for parameter \"args\"');\n      }\n\n      this.implicit = implicit === true;\n      this.isPercentage = isPercentage === true;\n      this.op = op;\n      this.fn = fn;\n      this.args = args || [];\n    }\n\n    get type() {\n      return name;\n    }\n\n    get isOperatorNode() {\n      return true;\n    }\n    /**\r\n     * Compile a node into a JavaScript function.\r\n     * This basically pre-calculates as much as possible and only leaves open\r\n     * calculations which depend on a dynamic scope with variables.\r\n     * @param {Object} math     Math.js namespace with functions and constants.\r\n     * @param {Object} argNames An object with argument names as key and `true`\r\n     *                          as value. Used in the SymbolNode to optimize\r\n     *                          for arguments from user assigned functions\r\n     *                          (see FunctionAssignmentNode) or special symbols\r\n     *                          like `end` (see IndexNode).\r\n     * @return {function} Returns a function which can be called like:\r\n     *                        evalNode(scope: Object, args: Object, context: *)\r\n     */\n\n\n    _compile(math, argNames) {\n      // validate fn\n      if (typeof this.fn !== 'string' || !isSafeMethod(math, this.fn)) {\n        if (!math[this.fn]) {\n          throw new Error('Function ' + this.fn + ' missing in provided namespace \"math\"');\n        } else {\n          throw new Error('No access to function \"' + this.fn + '\"');\n        }\n      }\n\n      var fn = getSafeProperty(math, this.fn);\n      var evalArgs = map(this.args, function (arg) {\n        return arg._compile(math, argNames);\n      });\n\n      if (evalArgs.length === 1) {\n        var evalArg0 = evalArgs[0];\n        return function evalOperatorNode(scope, args, context) {\n          return fn(evalArg0(scope, args, context));\n        };\n      } else if (evalArgs.length === 2) {\n        var _evalArg = evalArgs[0];\n        var evalArg1 = evalArgs[1];\n        return function evalOperatorNode(scope, args, context) {\n          return fn(_evalArg(scope, args, context), evalArg1(scope, args, context));\n        };\n      } else {\n        return function evalOperatorNode(scope, args, context) {\n          return fn.apply(null, map(evalArgs, function (evalArg) {\n            return evalArg(scope, args, context);\n          }));\n        };\n      }\n    }\n    /**\r\n     * Execute a callback for each of the child nodes of this node\r\n     * @param {function(child: Node, path: string, parent: Node)} callback\r\n     */\n\n\n    forEach(callback) {\n      for (var i = 0; i < this.args.length; i++) {\n        callback(this.args[i], 'args[' + i + ']', this);\n      }\n    }\n    /**\r\n     * Create a new OperatorNode whose children are the results of calling\r\n     * the provided callback function for each child of the original node.\r\n     * @param {function(child: Node, path: string, parent: Node): Node} callback\r\n     * @returns {OperatorNode} Returns a transformed copy of the node\r\n     */\n\n\n    map(callback) {\n      var args = [];\n\n      for (var i = 0; i < this.args.length; i++) {\n        args[i] = this._ifNode(callback(this.args[i], 'args[' + i + ']', this));\n      }\n\n      return new OperatorNode(this.op, this.fn, args, this.implicit, this.isPercentage);\n    }\n    /**\r\n     * Create a clone of this node, a shallow copy\r\n     * @return {OperatorNode}\r\n     */\n\n\n    clone() {\n      return new OperatorNode(this.op, this.fn, this.args.slice(0), this.implicit, this.isPercentage);\n    }\n    /**\r\n     * Check whether this is an unary OperatorNode:\r\n     * has exactly one argument, like `-a`.\r\n     * @return {boolean}\r\n     *     Returns true when an unary operator node, false otherwise.\r\n     */\n\n\n    isUnary() {\n      return this.args.length === 1;\n    }\n    /**\r\n     * Check whether this is a binary OperatorNode:\r\n     * has exactly two arguments, like `a + b`.\r\n     * @return {boolean}\r\n     *     Returns true when a binary operator node, false otherwise.\r\n     */\n\n\n    isBinary() {\n      return this.args.length === 2;\n    }\n    /**\r\n     * Get string representation.\r\n     * @param {Object} options\r\n     * @return {string} str\r\n     */\n\n\n    _toString(options) {\n      var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n      var implicit = options && options.implicit ? options.implicit : 'hide';\n      var args = this.args;\n      var parens = calculateNecessaryParentheses(this, parenthesis, implicit, args, false);\n\n      if (args.length === 1) {\n        // unary operators\n        var assoc = getAssociativity(this, parenthesis);\n        var operand = args[0].toString(options);\n\n        if (parens[0]) {\n          operand = '(' + operand + ')';\n        } // for example for \"not\", we want a space between operand and argument\n\n\n        var opIsNamed = /[a-zA-Z]+/.test(this.op);\n\n        if (assoc === 'right') {\n          // prefix operator\n          return this.op + (opIsNamed ? ' ' : '') + operand;\n        } else if (assoc === 'left') {\n          // postfix\n          return operand + (opIsNamed ? ' ' : '') + this.op;\n        } // fall back to postfix\n\n\n        return operand + this.op;\n      } else if (args.length === 2) {\n        var lhs = args[0].toString(options); // left hand side\n\n        var rhs = args[1].toString(options); // right hand side\n\n        if (parens[0]) {\n          // left hand side in parenthesis?\n          lhs = '(' + lhs + ')';\n        }\n\n        if (parens[1]) {\n          // right hand side in parenthesis?\n          rhs = '(' + rhs + ')';\n        }\n\n        if (this.implicit && this.getIdentifier() === 'OperatorNode:multiply' && implicit === 'hide') {\n          return lhs + ' ' + rhs;\n        }\n\n        return lhs + ' ' + this.op + ' ' + rhs;\n      } else if (args.length > 2 && (this.getIdentifier() === 'OperatorNode:add' || this.getIdentifier() === 'OperatorNode:multiply')) {\n        var stringifiedArgs = args.map(function (arg, index) {\n          arg = arg.toString(options);\n\n          if (parens[index]) {\n            // put in parenthesis?\n            arg = '(' + arg + ')';\n          }\n\n          return arg;\n        });\n\n        if (this.implicit && this.getIdentifier() === 'OperatorNode:multiply' && implicit === 'hide') {\n          return stringifiedArgs.join(' ');\n        }\n\n        return stringifiedArgs.join(' ' + this.op + ' ');\n      } else {\n        // fallback to formatting as a function call\n        return this.fn + '(' + this.args.join(', ') + ')';\n      }\n    }\n    /**\r\n     * Get a JSON representation of the node\r\n     * @returns {Object}\r\n     */\n\n\n    toJSON() {\n      return {\n        mathjs: name,\n        op: this.op,\n        fn: this.fn,\n        args: this.args,\n        implicit: this.implicit,\n        isPercentage: this.isPercentage\n      };\n    }\n    /**\r\n     * Instantiate an OperatorNode from its JSON representation\r\n     * @param {Object} json\r\n     *     An object structured like\r\n     *     ```\r\n     *     {\"mathjs\": \"OperatorNode\",\r\n     *      \"op\": \"+\", \"fn\": \"add\", \"args\": [...],\r\n     *      \"implicit\": false,\r\n     *      \"isPercentage\":false}\r\n     *     ```\r\n     *     where mathjs is optional\r\n     * @returns {OperatorNode}\r\n     */\n\n\n    static fromJSON(json) {\n      return new OperatorNode(json.op, json.fn, json.args, json.implicit, json.isPercentage);\n    }\n    /**\r\n     * Get HTML representation.\r\n     * @param {Object} options\r\n     * @return {string} str\r\n     */\n\n\n    toHTML(options) {\n      var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n      var implicit = options && options.implicit ? options.implicit : 'hide';\n      var args = this.args;\n      var parens = calculateNecessaryParentheses(this, parenthesis, implicit, args, false);\n\n      if (args.length === 1) {\n        // unary operators\n        var assoc = getAssociativity(this, parenthesis);\n        var operand = args[0].toHTML(options);\n\n        if (parens[0]) {\n          operand = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + operand + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n        }\n\n        if (assoc === 'right') {\n          // prefix operator\n          return '<span class=\"math-operator math-unary-operator ' + 'math-lefthand-unary-operator\">' + escape(this.op) + '</span>' + operand;\n        } else {\n          // postfix when assoc === 'left' or undefined\n          return operand + '<span class=\"math-operator math-unary-operator ' + 'math-righthand-unary-operator\">' + escape(this.op) + '</span>';\n        }\n      } else if (args.length === 2) {\n        // binary operatoes\n        var lhs = args[0].toHTML(options); // left hand side\n\n        var rhs = args[1].toHTML(options); // right hand side\n\n        if (parens[0]) {\n          // left hand side in parenthesis?\n          lhs = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + lhs + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n        }\n\n        if (parens[1]) {\n          // right hand side in parenthesis?\n          rhs = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + rhs + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n        }\n\n        if (this.implicit && this.getIdentifier() === 'OperatorNode:multiply' && implicit === 'hide') {\n          return lhs + '<span class=\"math-operator math-binary-operator ' + 'math-implicit-binary-operator\"></span>' + rhs;\n        }\n\n        return lhs + '<span class=\"math-operator math-binary-operator ' + 'math-explicit-binary-operator\">' + escape(this.op) + '</span>' + rhs;\n      } else {\n        var stringifiedArgs = args.map(function (arg, index) {\n          arg = arg.toHTML(options);\n\n          if (parens[index]) {\n            // put in parenthesis?\n            arg = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + arg + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n          }\n\n          return arg;\n        });\n\n        if (args.length > 2 && (this.getIdentifier() === 'OperatorNode:add' || this.getIdentifier() === 'OperatorNode:multiply')) {\n          if (this.implicit && this.getIdentifier() === 'OperatorNode:multiply' && implicit === 'hide') {\n            return stringifiedArgs.join('<span class=\"math-operator math-binary-operator ' + 'math-implicit-binary-operator\"></span>');\n          }\n\n          return stringifiedArgs.join('<span class=\"math-operator math-binary-operator ' + 'math-explicit-binary-operator\">' + escape(this.op) + '</span>');\n        } else {\n          // fallback to formatting as a function call\n          return '<span class=\"math-function\">' + escape(this.fn) + '</span><span class=\"math-paranthesis math-round-parenthesis\">' + '(</span>' + stringifiedArgs.join('<span class=\"math-separator\">,</span>') + '<span class=\"math-paranthesis math-round-parenthesis\">)</span>';\n        }\n      }\n    }\n    /**\r\n     * Get LaTeX representation\r\n     * @param {Object} options\r\n     * @return {string} str\r\n     */\n\n\n    _toTex(options) {\n      var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n      var implicit = options && options.implicit ? options.implicit : 'hide';\n      var args = this.args;\n      var parens = calculateNecessaryParentheses(this, parenthesis, implicit, args, true);\n      var op = latexOperators[this.fn];\n      op = typeof op === 'undefined' ? this.op : op; // fall back to using this.op\n\n      if (args.length === 1) {\n        // unary operators\n        var assoc = getAssociativity(this, parenthesis);\n        var operand = args[0].toTex(options);\n\n        if (parens[0]) {\n          operand = \"\\\\left(\".concat(operand, \"\\\\right)\");\n        }\n\n        if (assoc === 'right') {\n          // prefix operator\n          return op + operand;\n        } else if (assoc === 'left') {\n          // postfix operator\n          return operand + op;\n        } // fall back to postfix\n\n\n        return operand + op;\n      } else if (args.length === 2) {\n        // binary operators\n        var lhs = args[0]; // left hand side\n\n        var lhsTex = lhs.toTex(options);\n\n        if (parens[0]) {\n          lhsTex = \"\\\\left(\".concat(lhsTex, \"\\\\right)\");\n        }\n\n        var rhs = args[1]; // right hand side\n\n        var rhsTex = rhs.toTex(options);\n\n        if (parens[1]) {\n          rhsTex = \"\\\\left(\".concat(rhsTex, \"\\\\right)\");\n        } // handle some exceptions (due to the way LaTeX works)\n\n\n        var lhsIdentifier;\n\n        if (parenthesis === 'keep') {\n          lhsIdentifier = lhs.getIdentifier();\n        } else {\n          // Ignore ParenthesisNodes if in 'keep' mode\n          lhsIdentifier = lhs.getContent().getIdentifier();\n        }\n\n        switch (this.getIdentifier()) {\n          case 'OperatorNode:divide':\n            // op contains '\\\\frac' at this point\n            return op + '{' + lhsTex + '}' + '{' + rhsTex + '}';\n\n          case 'OperatorNode:pow':\n            lhsTex = '{' + lhsTex + '}';\n            rhsTex = '{' + rhsTex + '}';\n\n            switch (lhsIdentifier) {\n              case 'ConditionalNode': //\n\n              case 'OperatorNode:divide':\n                lhsTex = \"\\\\left(\".concat(lhsTex, \"\\\\right)\");\n            }\n\n            break;\n\n          case 'OperatorNode:multiply':\n            if (this.implicit && implicit === 'hide') {\n              return lhsTex + '~' + rhsTex;\n            }\n\n        }\n\n        return lhsTex + op + rhsTex;\n      } else if (args.length > 2 && (this.getIdentifier() === 'OperatorNode:add' || this.getIdentifier() === 'OperatorNode:multiply')) {\n        var texifiedArgs = args.map(function (arg, index) {\n          arg = arg.toTex(options);\n\n          if (parens[index]) {\n            arg = \"\\\\left(\".concat(arg, \"\\\\right)\");\n          }\n\n          return arg;\n        });\n\n        if (this.getIdentifier() === 'OperatorNode:multiply' && this.implicit && implicit === 'hide') {\n          return texifiedArgs.join('~');\n        }\n\n        return texifiedArgs.join(op);\n      } else {\n        // fall back to formatting as a function call\n        // as this is a fallback, it doesn't use\n        // fancy function names\n        return '\\\\mathrm{' + this.fn + '}\\\\left(' + args.map(function (arg) {\n          return arg.toTex(options);\n        }).join(',') + '\\\\right)';\n      }\n    }\n    /**\r\n     * Get identifier.\r\n     * @return {string}\r\n     */\n\n\n    getIdentifier() {\n      return this.type + ':' + this.fn;\n    }\n\n  }\n\n  _defineProperty(OperatorNode, \"name\", name);\n\n  return OperatorNode;\n}, {\n  isClass: true,\n  isNode: true\n});","map":{"version":3,"sources":["C:/Users/amase/Desktop/open_dsa/openDSA_dashboard/project/node_modules/mathjs/lib/esm/expression/node/OperatorNode.js"],"names":["_defineProperty","isNode","isConstantNode","isOperatorNode","isParenthesisNode","map","escape","getSafeProperty","isSafeMethod","getAssociativity","getPrecedence","isAssociativeWith","properties","latexOperators","factory","name","dependencies","createOperatorNode","_ref","Node","startsWithConstant","expr","parenthesis","curNode","content","args","calculateNecessaryParentheses","root","implicit","latex","precedence","associativity","length","getIdentifier","arg","getContent","type","result","operandPrecedence","operandIdentifier","rootIdentifier","latexLeftParens","latexParens","lhsParens","lhsPrecedence","assocWithLhs","rhsParens","rhsPrecedence","assocWithRhs","_rootIdentifier","lhsIdentifier","rhsIdentifier","latexRightParens","argPrecedence","assocWithArg","argAssociativity","i","OperatorNode","constructor","op","fn","isPercentage","TypeError","Array","isArray","every","_compile","math","argNames","Error","evalArgs","evalArg0","evalOperatorNode","scope","context","_evalArg","evalArg1","apply","evalArg","forEach","callback","_ifNode","clone","slice","isUnary","isBinary","_toString","options","parens","assoc","operand","toString","opIsNamed","test","lhs","rhs","stringifiedArgs","index","join","toJSON","mathjs","fromJSON","json","toHTML","_toTex","toTex","concat","lhsTex","rhsTex","texifiedArgs","isClass"],"mappings":"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","sourcesContent":["import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\r\nimport { isNode, isConstantNode, isOperatorNode, isParenthesisNode } from '../../utils/is.js';\r\nimport { map } from '../../utils/array.js';\r\nimport { escape } from '../../utils/string.js';\r\nimport { getSafeProperty, isSafeMethod } from '../../utils/customs.js';\r\nimport { getAssociativity, getPrecedence, isAssociativeWith, properties } from '../operators.js';\r\nimport { latexOperators } from '../../utils/latex.js';\r\nimport { factory } from '../../utils/factory.js';\r\nvar name = 'OperatorNode';\r\nvar dependencies = ['Node'];\r\nexport var createOperatorNode = /* #__PURE__ */factory(name, dependencies, _ref => {\r\n  var {\r\n    Node\r\n  } = _ref;\r\n  /**\r\n   * Returns true if the expression starts with a constant, under\r\n   * the current parenthesization:\r\n   * @param {Node} expression\r\n   * @param {string} parenthesis\r\n   * @return {boolean}\r\n   */\r\n  function startsWithConstant(expr, parenthesis) {\r\n    var curNode = expr;\r\n    if (parenthesis === 'auto') {\r\n      while (isParenthesisNode(curNode)) {\r\n        curNode = curNode.content;\r\n      }\r\n    }\r\n    if (isConstantNode(curNode)) return true;\r\n    if (isOperatorNode(curNode)) {\r\n      return startsWithConstant(curNode.args[0], parenthesis);\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Calculate which parentheses are necessary. Gets an OperatorNode\r\n   * (which is the root of the tree) and an Array of Nodes\r\n   * (this.args) and returns an array where 'true' means that an argument\r\n   * has to be enclosed in parentheses whereas 'false' means the opposite.\r\n   *\r\n   * @param {OperatorNode} root\r\n   * @param {string} parenthesis\r\n   * @param {Node[]} args\r\n   * @param {boolean} latex\r\n   * @return {boolean[]}\r\n   * @private\r\n   */\r\n  function calculateNecessaryParentheses(root, parenthesis, implicit, args, latex) {\r\n    // precedence of the root OperatorNode\r\n    var precedence = getPrecedence(root, parenthesis, implicit);\r\n    var associativity = getAssociativity(root, parenthesis);\r\n    if (parenthesis === 'all' || args.length > 2 && root.getIdentifier() !== 'OperatorNode:add' && root.getIdentifier() !== 'OperatorNode:multiply') {\r\n      return args.map(function (arg) {\r\n        switch (arg.getContent().type) {\r\n          // Nodes that don't need extra parentheses\r\n          case 'ArrayNode':\r\n          case 'ConstantNode':\r\n          case 'SymbolNode':\r\n          case 'ParenthesisNode':\r\n            return false;\r\n          default:\r\n            return true;\r\n        }\r\n      });\r\n    }\r\n    var result;\r\n    switch (args.length) {\r\n      case 0:\r\n        result = [];\r\n        break;\r\n      case 1:\r\n        // unary operators\r\n        {\r\n          // precedence of the operand\r\n          var operandPrecedence = getPrecedence(args[0], parenthesis, implicit, root);\r\n\r\n          // handle special cases for LaTeX, where some of the parentheses aren't needed\r\n          if (latex && operandPrecedence !== null) {\r\n            var operandIdentifier;\r\n            var rootIdentifier;\r\n            if (parenthesis === 'keep') {\r\n              operandIdentifier = args[0].getIdentifier();\r\n              rootIdentifier = root.getIdentifier();\r\n            } else {\r\n              // Ignore Parenthesis Nodes when not in 'keep' mode\r\n              operandIdentifier = args[0].getContent().getIdentifier();\r\n              rootIdentifier = root.getContent().getIdentifier();\r\n            }\r\n            if (properties[precedence][rootIdentifier].latexLeftParens === false) {\r\n              result = [false];\r\n              break;\r\n            }\r\n            if (properties[operandPrecedence][operandIdentifier].latexParens === false) {\r\n              result = [false];\r\n              break;\r\n            }\r\n          }\r\n          if (operandPrecedence === null) {\r\n            // if the operand has no defined precedence, no parens are needed\r\n            result = [false];\r\n            break;\r\n          }\r\n          if (operandPrecedence <= precedence) {\r\n            // if the operands precedence is lower, parens are needed\r\n            result = [true];\r\n            break;\r\n          }\r\n\r\n          // otherwise, no parens needed\r\n          result = [false];\r\n        }\r\n        break;\r\n      case 2:\r\n        // binary operators\r\n        {\r\n          var lhsParens; // left hand side needs parenthesis?\r\n          // precedence of the left hand side\r\n          var lhsPrecedence = getPrecedence(args[0], parenthesis, implicit, root);\r\n          // is the root node associative with the left hand side\r\n          var assocWithLhs = isAssociativeWith(root, args[0], parenthesis);\r\n          if (lhsPrecedence === null) {\r\n            // if the left hand side has no defined precedence, no parens are needed\r\n            // FunctionNode for example\r\n            lhsParens = false;\r\n          } else if (lhsPrecedence === precedence && associativity === 'right' && !assocWithLhs) {\r\n            // In case of equal precedence, if the root node is left associative\r\n            // parens are **never** necessary for the left hand side.\r\n            // If it is right associative however, parens are necessary\r\n            // if the root node isn't associative with the left hand side\r\n            lhsParens = true;\r\n          } else if (lhsPrecedence < precedence) {\r\n            lhsParens = true;\r\n          } else {\r\n            lhsParens = false;\r\n          }\r\n          var rhsParens; // right hand side needs parenthesis?\r\n          // precedence of the right hand side\r\n          var rhsPrecedence = getPrecedence(args[1], parenthesis, implicit, root);\r\n          // is the root node associative with the right hand side?\r\n          var assocWithRhs = isAssociativeWith(root, args[1], parenthesis);\r\n          if (rhsPrecedence === null) {\r\n            // if the right hand side has no defined precedence, no parens are needed\r\n            // FunctionNode for example\r\n            rhsParens = false;\r\n          } else if (rhsPrecedence === precedence && associativity === 'left' && !assocWithRhs) {\r\n            // In case of equal precedence, if the root node is right associative\r\n            // parens are **never** necessary for the right hand side.\r\n            // If it is left associative however, parens are necessary\r\n            // if the root node isn't associative with the right hand side\r\n            rhsParens = true;\r\n          } else if (rhsPrecedence < precedence) {\r\n            rhsParens = true;\r\n          } else {\r\n            rhsParens = false;\r\n          }\r\n\r\n          // handle special cases for LaTeX, where some of the parentheses aren't needed\r\n          if (latex) {\r\n            var _rootIdentifier;\r\n            var lhsIdentifier;\r\n            var rhsIdentifier;\r\n            if (parenthesis === 'keep') {\r\n              _rootIdentifier = root.getIdentifier();\r\n              lhsIdentifier = root.args[0].getIdentifier();\r\n              rhsIdentifier = root.args[1].getIdentifier();\r\n            } else {\r\n              // Ignore ParenthesisNodes when not in 'keep' mode\r\n              _rootIdentifier = root.getContent().getIdentifier();\r\n              lhsIdentifier = root.args[0].getContent().getIdentifier();\r\n              rhsIdentifier = root.args[1].getContent().getIdentifier();\r\n            }\r\n            if (lhsPrecedence !== null) {\r\n              if (properties[precedence][_rootIdentifier].latexLeftParens === false) {\r\n                lhsParens = false;\r\n              }\r\n              if (properties[lhsPrecedence][lhsIdentifier].latexParens === false) {\r\n                lhsParens = false;\r\n              }\r\n            }\r\n            if (rhsPrecedence !== null) {\r\n              if (properties[precedence][_rootIdentifier].latexRightParens === false) {\r\n                rhsParens = false;\r\n              }\r\n              if (properties[rhsPrecedence][rhsIdentifier].latexParens === false) {\r\n                rhsParens = false;\r\n              }\r\n            }\r\n          }\r\n          result = [lhsParens, rhsParens];\r\n        }\r\n        break;\r\n      default:\r\n        if (root.getIdentifier() === 'OperatorNode:add' || root.getIdentifier() === 'OperatorNode:multiply') {\r\n          result = args.map(function (arg) {\r\n            var argPrecedence = getPrecedence(arg, parenthesis, implicit, root);\r\n            var assocWithArg = isAssociativeWith(root, arg, parenthesis);\r\n            var argAssociativity = getAssociativity(arg, parenthesis);\r\n            if (argPrecedence === null) {\r\n              // if the argument has no defined precedence, no parens are needed\r\n              return false;\r\n            } else if (precedence === argPrecedence && associativity === argAssociativity && !assocWithArg) {\r\n              return true;\r\n            } else if (argPrecedence < precedence) {\r\n              return true;\r\n            }\r\n            return false;\r\n          });\r\n        }\r\n        break;\r\n    }\r\n\r\n    // Handles an edge case of parentheses with implicit multiplication\r\n    // of ConstantNode.\r\n    // In that case, parenthesize ConstantNodes that follow an unparenthesized\r\n    // expression, even though they normally wouldn't be printed.\r\n    if (args.length >= 2 && root.getIdentifier() === 'OperatorNode:multiply' && root.implicit && parenthesis !== 'all' && implicit === 'hide') {\r\n      for (var i = 1; i < result.length; ++i) {\r\n        if (startsWithConstant(args[i], parenthesis) && !result[i - 1] && (parenthesis !== 'keep' || !isParenthesisNode(args[i - 1]))) {\r\n          result[i] = true;\r\n        }\r\n      }\r\n    }\r\n    return result;\r\n  }\r\n  class OperatorNode extends Node {\r\n    /**\r\n     * @constructor OperatorNode\r\n     * @extends {Node}\r\n     * An operator with two arguments, like 2+3\r\n     *\r\n     * @param {string} op           Operator name, for example '+'\r\n     * @param {string} fn           Function name, for example 'add'\r\n     * @param {Node[]} args         Operator arguments\r\n     * @param {boolean} [implicit]  Is this an implicit multiplication?\r\n     * @param {boolean} [isPercentage] Is this an percentage Operation?\r\n     */\r\n    constructor(op, fn, args, implicit, isPercentage) {\r\n      super();\r\n      // validate input\r\n      if (typeof op !== 'string') {\r\n        throw new TypeError('string expected for parameter \"op\"');\r\n      }\r\n      if (typeof fn !== 'string') {\r\n        throw new TypeError('string expected for parameter \"fn\"');\r\n      }\r\n      if (!Array.isArray(args) || !args.every(isNode)) {\r\n        throw new TypeError('Array containing Nodes expected for parameter \"args\"');\r\n      }\r\n      this.implicit = implicit === true;\r\n      this.isPercentage = isPercentage === true;\r\n      this.op = op;\r\n      this.fn = fn;\r\n      this.args = args || [];\r\n    }\r\n    get type() {\r\n      return name;\r\n    }\r\n    get isOperatorNode() {\r\n      return true;\r\n    }\r\n\r\n    /**\r\n     * Compile a node into a JavaScript function.\r\n     * This basically pre-calculates as much as possible and only leaves open\r\n     * calculations which depend on a dynamic scope with variables.\r\n     * @param {Object} math     Math.js namespace with functions and constants.\r\n     * @param {Object} argNames An object with argument names as key and `true`\r\n     *                          as value. Used in the SymbolNode to optimize\r\n     *                          for arguments from user assigned functions\r\n     *                          (see FunctionAssignmentNode) or special symbols\r\n     *                          like `end` (see IndexNode).\r\n     * @return {function} Returns a function which can be called like:\r\n     *                        evalNode(scope: Object, args: Object, context: *)\r\n     */\r\n    _compile(math, argNames) {\r\n      // validate fn\r\n      if (typeof this.fn !== 'string' || !isSafeMethod(math, this.fn)) {\r\n        if (!math[this.fn]) {\r\n          throw new Error('Function ' + this.fn + ' missing in provided namespace \"math\"');\r\n        } else {\r\n          throw new Error('No access to function \"' + this.fn + '\"');\r\n        }\r\n      }\r\n      var fn = getSafeProperty(math, this.fn);\r\n      var evalArgs = map(this.args, function (arg) {\r\n        return arg._compile(math, argNames);\r\n      });\r\n      if (evalArgs.length === 1) {\r\n        var evalArg0 = evalArgs[0];\r\n        return function evalOperatorNode(scope, args, context) {\r\n          return fn(evalArg0(scope, args, context));\r\n        };\r\n      } else if (evalArgs.length === 2) {\r\n        var _evalArg = evalArgs[0];\r\n        var evalArg1 = evalArgs[1];\r\n        return function evalOperatorNode(scope, args, context) {\r\n          return fn(_evalArg(scope, args, context), evalArg1(scope, args, context));\r\n        };\r\n      } else {\r\n        return function evalOperatorNode(scope, args, context) {\r\n          return fn.apply(null, map(evalArgs, function (evalArg) {\r\n            return evalArg(scope, args, context);\r\n          }));\r\n        };\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Execute a callback for each of the child nodes of this node\r\n     * @param {function(child: Node, path: string, parent: Node)} callback\r\n     */\r\n    forEach(callback) {\r\n      for (var i = 0; i < this.args.length; i++) {\r\n        callback(this.args[i], 'args[' + i + ']', this);\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Create a new OperatorNode whose children are the results of calling\r\n     * the provided callback function for each child of the original node.\r\n     * @param {function(child: Node, path: string, parent: Node): Node} callback\r\n     * @returns {OperatorNode} Returns a transformed copy of the node\r\n     */\r\n    map(callback) {\r\n      var args = [];\r\n      for (var i = 0; i < this.args.length; i++) {\r\n        args[i] = this._ifNode(callback(this.args[i], 'args[' + i + ']', this));\r\n      }\r\n      return new OperatorNode(this.op, this.fn, args, this.implicit, this.isPercentage);\r\n    }\r\n\r\n    /**\r\n     * Create a clone of this node, a shallow copy\r\n     * @return {OperatorNode}\r\n     */\r\n    clone() {\r\n      return new OperatorNode(this.op, this.fn, this.args.slice(0), this.implicit, this.isPercentage);\r\n    }\r\n\r\n    /**\r\n     * Check whether this is an unary OperatorNode:\r\n     * has exactly one argument, like `-a`.\r\n     * @return {boolean}\r\n     *     Returns true when an unary operator node, false otherwise.\r\n     */\r\n    isUnary() {\r\n      return this.args.length === 1;\r\n    }\r\n\r\n    /**\r\n     * Check whether this is a binary OperatorNode:\r\n     * has exactly two arguments, like `a + b`.\r\n     * @return {boolean}\r\n     *     Returns true when a binary operator node, false otherwise.\r\n     */\r\n    isBinary() {\r\n      return this.args.length === 2;\r\n    }\r\n\r\n    /**\r\n     * Get string representation.\r\n     * @param {Object} options\r\n     * @return {string} str\r\n     */\r\n    _toString(options) {\r\n      var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\r\n      var implicit = options && options.implicit ? options.implicit : 'hide';\r\n      var args = this.args;\r\n      var parens = calculateNecessaryParentheses(this, parenthesis, implicit, args, false);\r\n      if (args.length === 1) {\r\n        // unary operators\r\n        var assoc = getAssociativity(this, parenthesis);\r\n        var operand = args[0].toString(options);\r\n        if (parens[0]) {\r\n          operand = '(' + operand + ')';\r\n        }\r\n\r\n        // for example for \"not\", we want a space between operand and argument\r\n        var opIsNamed = /[a-zA-Z]+/.test(this.op);\r\n        if (assoc === 'right') {\r\n          // prefix operator\r\n          return this.op + (opIsNamed ? ' ' : '') + operand;\r\n        } else if (assoc === 'left') {\r\n          // postfix\r\n          return operand + (opIsNamed ? ' ' : '') + this.op;\r\n        }\r\n\r\n        // fall back to postfix\r\n        return operand + this.op;\r\n      } else if (args.length === 2) {\r\n        var lhs = args[0].toString(options); // left hand side\r\n        var rhs = args[1].toString(options); // right hand side\r\n        if (parens[0]) {\r\n          // left hand side in parenthesis?\r\n          lhs = '(' + lhs + ')';\r\n        }\r\n        if (parens[1]) {\r\n          // right hand side in parenthesis?\r\n          rhs = '(' + rhs + ')';\r\n        }\r\n        if (this.implicit && this.getIdentifier() === 'OperatorNode:multiply' && implicit === 'hide') {\r\n          return lhs + ' ' + rhs;\r\n        }\r\n        return lhs + ' ' + this.op + ' ' + rhs;\r\n      } else if (args.length > 2 && (this.getIdentifier() === 'OperatorNode:add' || this.getIdentifier() === 'OperatorNode:multiply')) {\r\n        var stringifiedArgs = args.map(function (arg, index) {\r\n          arg = arg.toString(options);\r\n          if (parens[index]) {\r\n            // put in parenthesis?\r\n            arg = '(' + arg + ')';\r\n          }\r\n          return arg;\r\n        });\r\n        if (this.implicit && this.getIdentifier() === 'OperatorNode:multiply' && implicit === 'hide') {\r\n          return stringifiedArgs.join(' ');\r\n        }\r\n        return stringifiedArgs.join(' ' + this.op + ' ');\r\n      } else {\r\n        // fallback to formatting as a function call\r\n        return this.fn + '(' + this.args.join(', ') + ')';\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Get a JSON representation of the node\r\n     * @returns {Object}\r\n     */\r\n    toJSON() {\r\n      return {\r\n        mathjs: name,\r\n        op: this.op,\r\n        fn: this.fn,\r\n        args: this.args,\r\n        implicit: this.implicit,\r\n        isPercentage: this.isPercentage\r\n      };\r\n    }\r\n\r\n    /**\r\n     * Instantiate an OperatorNode from its JSON representation\r\n     * @param {Object} json\r\n     *     An object structured like\r\n     *     ```\r\n     *     {\"mathjs\": \"OperatorNode\",\r\n     *      \"op\": \"+\", \"fn\": \"add\", \"args\": [...],\r\n     *      \"implicit\": false,\r\n     *      \"isPercentage\":false}\r\n     *     ```\r\n     *     where mathjs is optional\r\n     * @returns {OperatorNode}\r\n     */\r\n    static fromJSON(json) {\r\n      return new OperatorNode(json.op, json.fn, json.args, json.implicit, json.isPercentage);\r\n    }\r\n\r\n    /**\r\n     * Get HTML representation.\r\n     * @param {Object} options\r\n     * @return {string} str\r\n     */\r\n    toHTML(options) {\r\n      var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\r\n      var implicit = options && options.implicit ? options.implicit : 'hide';\r\n      var args = this.args;\r\n      var parens = calculateNecessaryParentheses(this, parenthesis, implicit, args, false);\r\n      if (args.length === 1) {\r\n        // unary operators\r\n        var assoc = getAssociativity(this, parenthesis);\r\n        var operand = args[0].toHTML(options);\r\n        if (parens[0]) {\r\n          operand = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + operand + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\r\n        }\r\n        if (assoc === 'right') {\r\n          // prefix operator\r\n          return '<span class=\"math-operator math-unary-operator ' + 'math-lefthand-unary-operator\">' + escape(this.op) + '</span>' + operand;\r\n        } else {\r\n          // postfix when assoc === 'left' or undefined\r\n          return operand + '<span class=\"math-operator math-unary-operator ' + 'math-righthand-unary-operator\">' + escape(this.op) + '</span>';\r\n        }\r\n      } else if (args.length === 2) {\r\n        // binary operatoes\r\n        var lhs = args[0].toHTML(options); // left hand side\r\n        var rhs = args[1].toHTML(options); // right hand side\r\n        if (parens[0]) {\r\n          // left hand side in parenthesis?\r\n          lhs = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + lhs + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\r\n        }\r\n        if (parens[1]) {\r\n          // right hand side in parenthesis?\r\n          rhs = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + rhs + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\r\n        }\r\n        if (this.implicit && this.getIdentifier() === 'OperatorNode:multiply' && implicit === 'hide') {\r\n          return lhs + '<span class=\"math-operator math-binary-operator ' + 'math-implicit-binary-operator\"></span>' + rhs;\r\n        }\r\n        return lhs + '<span class=\"math-operator math-binary-operator ' + 'math-explicit-binary-operator\">' + escape(this.op) + '</span>' + rhs;\r\n      } else {\r\n        var stringifiedArgs = args.map(function (arg, index) {\r\n          arg = arg.toHTML(options);\r\n          if (parens[index]) {\r\n            // put in parenthesis?\r\n            arg = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + arg + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\r\n          }\r\n          return arg;\r\n        });\r\n        if (args.length > 2 && (this.getIdentifier() === 'OperatorNode:add' || this.getIdentifier() === 'OperatorNode:multiply')) {\r\n          if (this.implicit && this.getIdentifier() === 'OperatorNode:multiply' && implicit === 'hide') {\r\n            return stringifiedArgs.join('<span class=\"math-operator math-binary-operator ' + 'math-implicit-binary-operator\"></span>');\r\n          }\r\n          return stringifiedArgs.join('<span class=\"math-operator math-binary-operator ' + 'math-explicit-binary-operator\">' + escape(this.op) + '</span>');\r\n        } else {\r\n          // fallback to formatting as a function call\r\n          return '<span class=\"math-function\">' + escape(this.fn) + '</span><span class=\"math-paranthesis math-round-parenthesis\">' + '(</span>' + stringifiedArgs.join('<span class=\"math-separator\">,</span>') + '<span class=\"math-paranthesis math-round-parenthesis\">)</span>';\r\n        }\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Get LaTeX representation\r\n     * @param {Object} options\r\n     * @return {string} str\r\n     */\r\n    _toTex(options) {\r\n      var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\r\n      var implicit = options && options.implicit ? options.implicit : 'hide';\r\n      var args = this.args;\r\n      var parens = calculateNecessaryParentheses(this, parenthesis, implicit, args, true);\r\n      var op = latexOperators[this.fn];\r\n      op = typeof op === 'undefined' ? this.op : op; // fall back to using this.op\r\n\r\n      if (args.length === 1) {\r\n        // unary operators\r\n        var assoc = getAssociativity(this, parenthesis);\r\n        var operand = args[0].toTex(options);\r\n        if (parens[0]) {\r\n          operand = \"\\\\left(\".concat(operand, \"\\\\right)\");\r\n        }\r\n        if (assoc === 'right') {\r\n          // prefix operator\r\n          return op + operand;\r\n        } else if (assoc === 'left') {\r\n          // postfix operator\r\n          return operand + op;\r\n        }\r\n\r\n        // fall back to postfix\r\n        return operand + op;\r\n      } else if (args.length === 2) {\r\n        // binary operators\r\n        var lhs = args[0]; // left hand side\r\n        var lhsTex = lhs.toTex(options);\r\n        if (parens[0]) {\r\n          lhsTex = \"\\\\left(\".concat(lhsTex, \"\\\\right)\");\r\n        }\r\n        var rhs = args[1]; // right hand side\r\n        var rhsTex = rhs.toTex(options);\r\n        if (parens[1]) {\r\n          rhsTex = \"\\\\left(\".concat(rhsTex, \"\\\\right)\");\r\n        }\r\n\r\n        // handle some exceptions (due to the way LaTeX works)\r\n        var lhsIdentifier;\r\n        if (parenthesis === 'keep') {\r\n          lhsIdentifier = lhs.getIdentifier();\r\n        } else {\r\n          // Ignore ParenthesisNodes if in 'keep' mode\r\n          lhsIdentifier = lhs.getContent().getIdentifier();\r\n        }\r\n        switch (this.getIdentifier()) {\r\n          case 'OperatorNode:divide':\r\n            // op contains '\\\\frac' at this point\r\n            return op + '{' + lhsTex + '}' + '{' + rhsTex + '}';\r\n          case 'OperatorNode:pow':\r\n            lhsTex = '{' + lhsTex + '}';\r\n            rhsTex = '{' + rhsTex + '}';\r\n            switch (lhsIdentifier) {\r\n              case 'ConditionalNode': //\r\n              case 'OperatorNode:divide':\r\n                lhsTex = \"\\\\left(\".concat(lhsTex, \"\\\\right)\");\r\n            }\r\n            break;\r\n          case 'OperatorNode:multiply':\r\n            if (this.implicit && implicit === 'hide') {\r\n              return lhsTex + '~' + rhsTex;\r\n            }\r\n        }\r\n        return lhsTex + op + rhsTex;\r\n      } else if (args.length > 2 && (this.getIdentifier() === 'OperatorNode:add' || this.getIdentifier() === 'OperatorNode:multiply')) {\r\n        var texifiedArgs = args.map(function (arg, index) {\r\n          arg = arg.toTex(options);\r\n          if (parens[index]) {\r\n            arg = \"\\\\left(\".concat(arg, \"\\\\right)\");\r\n          }\r\n          return arg;\r\n        });\r\n        if (this.getIdentifier() === 'OperatorNode:multiply' && this.implicit && implicit === 'hide') {\r\n          return texifiedArgs.join('~');\r\n        }\r\n        return texifiedArgs.join(op);\r\n      } else {\r\n        // fall back to formatting as a function call\r\n        // as this is a fallback, it doesn't use\r\n        // fancy function names\r\n        return '\\\\mathrm{' + this.fn + '}\\\\left(' + args.map(function (arg) {\r\n          return arg.toTex(options);\r\n        }).join(',') + '\\\\right)';\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Get identifier.\r\n     * @return {string}\r\n     */\r\n    getIdentifier() {\r\n      return this.type + ':' + this.fn;\r\n    }\r\n  }\r\n  _defineProperty(OperatorNode, \"name\", name);\r\n  return OperatorNode;\r\n}, {\r\n  isClass: true,\r\n  isNode: true\r\n});"]},"metadata":{},"sourceType":"module"}