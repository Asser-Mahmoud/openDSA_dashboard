{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport { isArrayNode, isNode } from '../../utils/is.js';\nimport { map } from '../../utils/array.js';\nimport { factory } from '../../utils/factory.js';\nvar name = 'ArrayNode';\nvar dependencies = ['Node'];\nexport var createArrayNode = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    Node\n  } = _ref;\n\n  class ArrayNode extends Node {\n    /**\r\n     * @constructor ArrayNode\r\n     * @extends {Node}\r\n     * Holds an 1-dimensional array with items\r\n     * @param {Node[]} [items]   1 dimensional array with items\r\n     */\n    constructor(items) {\n      super();\n      this.items = items || []; // validate input\n\n      if (!Array.isArray(this.items) || !this.items.every(isNode)) {\n        throw new TypeError('Array containing Nodes expected');\n      }\n    }\n\n    get type() {\n      return name;\n    }\n\n    get isArrayNode() {\n      return true;\n    }\n    /**\r\n     * Compile a node into a JavaScript function.\r\n     * This basically pre-calculates as much as possible and only leaves open\r\n     * calculations which depend on a dynamic scope with variables.\r\n     * @param {Object} math     Math.js namespace with functions and constants.\r\n     * @param {Object} argNames An object with argument names as key and `true`\r\n     *                          as value. Used in the SymbolNode to optimize\r\n     *                          for arguments from user assigned functions\r\n     *                          (see FunctionAssignmentNode) or special symbols\r\n     *                          like `end` (see IndexNode).\r\n     * @return {function} Returns a function which can be called like:\r\n     *                        evalNode(scope: Object, args: Object, context: *)\r\n     */\n\n\n    _compile(math, argNames) {\n      var evalItems = map(this.items, function (item) {\n        return item._compile(math, argNames);\n      });\n      var asMatrix = math.config.matrix !== 'Array';\n\n      if (asMatrix) {\n        var matrix = math.matrix;\n        return function evalArrayNode(scope, args, context) {\n          return matrix(map(evalItems, function (evalItem) {\n            return evalItem(scope, args, context);\n          }));\n        };\n      } else {\n        return function evalArrayNode(scope, args, context) {\n          return map(evalItems, function (evalItem) {\n            return evalItem(scope, args, context);\n          });\n        };\n      }\n    }\n    /**\r\n     * Execute a callback for each of the child nodes of this node\r\n     * @param {function(child: Node, path: string, parent: Node)} callback\r\n     */\n\n\n    forEach(callback) {\n      for (var i = 0; i < this.items.length; i++) {\n        var node = this.items[i];\n        callback(node, 'items[' + i + ']', this);\n      }\n    }\n    /**\r\n     * Create a new ArrayNode whose children are the results of calling\r\n     * the provided callback function for each child of the original node.\r\n     * @param {function(child: Node, path: string, parent: Node): Node} callback\r\n     * @returns {ArrayNode} Returns a transformed copy of the node\r\n     */\n\n\n    map(callback) {\n      var items = [];\n\n      for (var i = 0; i < this.items.length; i++) {\n        items[i] = this._ifNode(callback(this.items[i], 'items[' + i + ']', this));\n      }\n\n      return new ArrayNode(items);\n    }\n    /**\r\n     * Create a clone of this node, a shallow copy\r\n     * @return {ArrayNode}\r\n     */\n\n\n    clone() {\n      return new ArrayNode(this.items.slice(0));\n    }\n    /**\r\n     * Get string representation\r\n     * @param {Object} options\r\n     * @return {string} str\r\n     * @override\r\n     */\n\n\n    _toString(options) {\n      var items = this.items.map(function (node) {\n        return node.toString(options);\n      });\n      return '[' + items.join(', ') + ']';\n    }\n    /**\r\n     * Get a JSON representation of the node\r\n     * @returns {Object}\r\n     */\n\n\n    toJSON() {\n      return {\n        mathjs: name,\n        items: this.items\n      };\n    }\n    /**\r\n     * Instantiate an ArrayNode from its JSON representation\r\n     * @param {Object} json  An object structured like\r\n     *                       `{\"mathjs\": \"ArrayNode\", items: [...]}`,\r\n     *                       where mathjs is optional\r\n     * @returns {ArrayNode}\r\n     */\n\n\n    static fromJSON(json) {\n      return new ArrayNode(json.items);\n    }\n    /**\r\n     * Get HTML representation\r\n     * @param {Object} options\r\n     * @return {string} str\r\n     * @override\r\n     */\n\n\n    toHTML(options) {\n      var items = this.items.map(function (node) {\n        return node.toHTML(options);\n      });\n      return '<span class=\"math-parenthesis math-square-parenthesis\">[</span>' + items.join('<span class=\"math-separator\">,</span>') + '<span class=\"math-parenthesis math-square-parenthesis\">]</span>';\n    }\n    /**\r\n     * Get LaTeX representation\r\n     * @param {Object} options\r\n     * @return {string} str\r\n     */\n\n\n    _toTex(options) {\n      function itemsToTex(items, nested) {\n        var mixedItems = items.some(isArrayNode) && !items.every(isArrayNode);\n        var itemsFormRow = nested || mixedItems;\n        var itemSep = itemsFormRow ? '&' : '\\\\\\\\';\n        var itemsTex = items.map(function (node) {\n          if (node.items) {\n            return itemsToTex(node.items, !nested);\n          } else {\n            return node.toTex(options);\n          }\n        }).join(itemSep);\n        return mixedItems || !itemsFormRow || itemsFormRow && !nested ? '\\\\begin{bmatrix}' + itemsTex + '\\\\end{bmatrix}' : itemsTex;\n      }\n\n      return itemsToTex(this.items, false);\n    }\n\n  }\n\n  _defineProperty(ArrayNode, \"name\", name);\n\n  return ArrayNode;\n}, {\n  isClass: true,\n  isNode: true\n});","map":{"version":3,"sources":["C:/Users/x/Desktop/openDSA/openDSA_dashboard/project/node_modules/mathjs/lib/esm/expression/node/ArrayNode.js"],"names":["_defineProperty","isArrayNode","isNode","map","factory","name","dependencies","createArrayNode","_ref","Node","ArrayNode","constructor","items","Array","isArray","every","TypeError","type","_compile","math","argNames","evalItems","item","asMatrix","config","matrix","evalArrayNode","scope","args","context","evalItem","forEach","callback","i","length","node","_ifNode","clone","slice","_toString","options","toString","join","toJSON","mathjs","fromJSON","json","toHTML","_toTex","itemsToTex","nested","mixedItems","some","itemsFormRow","itemSep","itemsTex","toTex","isClass"],"mappings":"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","sourcesContent":["import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\r\nimport { isArrayNode, isNode } from '../../utils/is.js';\r\nimport { map } from '../../utils/array.js';\r\nimport { factory } from '../../utils/factory.js';\r\nvar name = 'ArrayNode';\r\nvar dependencies = ['Node'];\r\nexport var createArrayNode = /* #__PURE__ */factory(name, dependencies, _ref => {\r\n  var {\r\n    Node\r\n  } = _ref;\r\n  class ArrayNode extends Node {\r\n    /**\r\n     * @constructor ArrayNode\r\n     * @extends {Node}\r\n     * Holds an 1-dimensional array with items\r\n     * @param {Node[]} [items]   1 dimensional array with items\r\n     */\r\n    constructor(items) {\r\n      super();\r\n      this.items = items || [];\r\n\r\n      // validate input\r\n      if (!Array.isArray(this.items) || !this.items.every(isNode)) {\r\n        throw new TypeError('Array containing Nodes expected');\r\n      }\r\n    }\r\n    get type() {\r\n      return name;\r\n    }\r\n    get isArrayNode() {\r\n      return true;\r\n    }\r\n\r\n    /**\r\n     * Compile a node into a JavaScript function.\r\n     * This basically pre-calculates as much as possible and only leaves open\r\n     * calculations which depend on a dynamic scope with variables.\r\n     * @param {Object} math     Math.js namespace with functions and constants.\r\n     * @param {Object} argNames An object with argument names as key and `true`\r\n     *                          as value. Used in the SymbolNode to optimize\r\n     *                          for arguments from user assigned functions\r\n     *                          (see FunctionAssignmentNode) or special symbols\r\n     *                          like `end` (see IndexNode).\r\n     * @return {function} Returns a function which can be called like:\r\n     *                        evalNode(scope: Object, args: Object, context: *)\r\n     */\r\n    _compile(math, argNames) {\r\n      var evalItems = map(this.items, function (item) {\r\n        return item._compile(math, argNames);\r\n      });\r\n      var asMatrix = math.config.matrix !== 'Array';\r\n      if (asMatrix) {\r\n        var matrix = math.matrix;\r\n        return function evalArrayNode(scope, args, context) {\r\n          return matrix(map(evalItems, function (evalItem) {\r\n            return evalItem(scope, args, context);\r\n          }));\r\n        };\r\n      } else {\r\n        return function evalArrayNode(scope, args, context) {\r\n          return map(evalItems, function (evalItem) {\r\n            return evalItem(scope, args, context);\r\n          });\r\n        };\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Execute a callback for each of the child nodes of this node\r\n     * @param {function(child: Node, path: string, parent: Node)} callback\r\n     */\r\n    forEach(callback) {\r\n      for (var i = 0; i < this.items.length; i++) {\r\n        var node = this.items[i];\r\n        callback(node, 'items[' + i + ']', this);\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Create a new ArrayNode whose children are the results of calling\r\n     * the provided callback function for each child of the original node.\r\n     * @param {function(child: Node, path: string, parent: Node): Node} callback\r\n     * @returns {ArrayNode} Returns a transformed copy of the node\r\n     */\r\n    map(callback) {\r\n      var items = [];\r\n      for (var i = 0; i < this.items.length; i++) {\r\n        items[i] = this._ifNode(callback(this.items[i], 'items[' + i + ']', this));\r\n      }\r\n      return new ArrayNode(items);\r\n    }\r\n\r\n    /**\r\n     * Create a clone of this node, a shallow copy\r\n     * @return {ArrayNode}\r\n     */\r\n    clone() {\r\n      return new ArrayNode(this.items.slice(0));\r\n    }\r\n\r\n    /**\r\n     * Get string representation\r\n     * @param {Object} options\r\n     * @return {string} str\r\n     * @override\r\n     */\r\n    _toString(options) {\r\n      var items = this.items.map(function (node) {\r\n        return node.toString(options);\r\n      });\r\n      return '[' + items.join(', ') + ']';\r\n    }\r\n\r\n    /**\r\n     * Get a JSON representation of the node\r\n     * @returns {Object}\r\n     */\r\n    toJSON() {\r\n      return {\r\n        mathjs: name,\r\n        items: this.items\r\n      };\r\n    }\r\n\r\n    /**\r\n     * Instantiate an ArrayNode from its JSON representation\r\n     * @param {Object} json  An object structured like\r\n     *                       `{\"mathjs\": \"ArrayNode\", items: [...]}`,\r\n     *                       where mathjs is optional\r\n     * @returns {ArrayNode}\r\n     */\r\n    static fromJSON(json) {\r\n      return new ArrayNode(json.items);\r\n    }\r\n\r\n    /**\r\n     * Get HTML representation\r\n     * @param {Object} options\r\n     * @return {string} str\r\n     * @override\r\n     */\r\n    toHTML(options) {\r\n      var items = this.items.map(function (node) {\r\n        return node.toHTML(options);\r\n      });\r\n      return '<span class=\"math-parenthesis math-square-parenthesis\">[</span>' + items.join('<span class=\"math-separator\">,</span>') + '<span class=\"math-parenthesis math-square-parenthesis\">]</span>';\r\n    }\r\n\r\n    /**\r\n     * Get LaTeX representation\r\n     * @param {Object} options\r\n     * @return {string} str\r\n     */\r\n    _toTex(options) {\r\n      function itemsToTex(items, nested) {\r\n        var mixedItems = items.some(isArrayNode) && !items.every(isArrayNode);\r\n        var itemsFormRow = nested || mixedItems;\r\n        var itemSep = itemsFormRow ? '&' : '\\\\\\\\';\r\n        var itemsTex = items.map(function (node) {\r\n          if (node.items) {\r\n            return itemsToTex(node.items, !nested);\r\n          } else {\r\n            return node.toTex(options);\r\n          }\r\n        }).join(itemSep);\r\n        return mixedItems || !itemsFormRow || itemsFormRow && !nested ? '\\\\begin{bmatrix}' + itemsTex + '\\\\end{bmatrix}' : itemsTex;\r\n      }\r\n      return itemsToTex(this.items, false);\r\n    }\r\n  }\r\n  _defineProperty(ArrayNode, \"name\", name);\r\n  return ArrayNode;\r\n}, {\r\n  isClass: true,\r\n  isNode: true\r\n});"]},"metadata":{},"sourceType":"module"}