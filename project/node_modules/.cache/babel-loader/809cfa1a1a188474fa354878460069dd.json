{"ast":null,"code":"import { factory } from '../../utils/factory.js';\nimport { gammaG, gammaNumber, gammaP } from '../../plain/number/index.js';\nvar name = 'gamma';\nvar dependencies = ['typed', 'config', 'multiplyScalar', 'pow', 'BigNumber', 'Complex'];\nexport var createGamma = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    config,\n    multiplyScalar,\n    pow,\n    BigNumber: _BigNumber,\n    Complex\n  } = _ref;\n  /**\r\n   * Compute the gamma function of a value using Lanczos approximation for\r\n   * small values, and an extended Stirling approximation for large values.\r\n   *\r\n   * To avoid confusion with the matrix Gamma function, this function does\r\n   * not apply to matrices.\r\n   *\r\n   * Syntax:\r\n   *\r\n   *    math.gamma(n)\r\n   *\r\n   * Examples:\r\n   *\r\n   *    math.gamma(5)       // returns 24\r\n   *    math.gamma(-0.5)    // returns -3.5449077018110335\r\n   *    math.gamma(math.i)  // returns -0.15494982830180973 - 0.49801566811835596i\r\n   *\r\n   * See also:\r\n   *\r\n   *    combinations, factorial, permutations\r\n   *\r\n   * @param {number | BigNumber | Complex} n   A real or complex number\r\n   * @return {number | BigNumber | Complex}    The gamma of `n`\r\n   */\n\n  function gammaComplex(n) {\n    if (n.im === 0) {\n      return gammaNumber(n.re);\n    } // Lanczos approximation doesn't work well with real part lower than 0.5\n    // So reflection formula is required\n\n\n    if (n.re < 0.5) {\n      // Euler's reflection formula\n      // gamma(1-z) * gamma(z) = PI / sin(PI * z)\n      // real part of Z should not be integer [sin(PI) == 0 -> 1/0 - undefined]\n      // thanks to imperfect sin implementation sin(PI * n) != 0\n      // we can safely use it anyway\n      var _t = new Complex(1 - n.re, -n.im);\n\n      var r = new Complex(Math.PI * n.re, Math.PI * n.im);\n      return new Complex(Math.PI).div(r.sin()).div(gammaComplex(_t));\n    } // Lanczos approximation\n    // z -= 1\n\n\n    n = new Complex(n.re - 1, n.im); // x = gammaPval[0]\n\n    var x = new Complex(gammaP[0], 0); // for (i, gammaPval) in enumerate(gammaP):\n\n    for (var i = 1; i < gammaP.length; ++i) {\n      // x += gammaPval / (z + i)\n      var gammaPval = new Complex(gammaP[i], 0);\n      x = x.add(gammaPval.div(n.add(i)));\n    } // t = z + gammaG + 0.5\n\n\n    var t = new Complex(n.re + gammaG + 0.5, n.im); // y = sqrt(2 * pi) * t ** (z + 0.5) * exp(-t) * x\n\n    var twoPiSqrt = Math.sqrt(2 * Math.PI);\n    var tpow = t.pow(n.add(0.5));\n    var expt = t.neg().exp(); // y = [x] * [sqrt(2 * pi)] * [t ** (z + 0.5)] * [exp(-t)]\n\n    return x.mul(twoPiSqrt).mul(tpow).mul(expt);\n  }\n\n  return typed(name, {\n    number: gammaNumber,\n    Complex: gammaComplex,\n    BigNumber: function BigNumber(n) {\n      if (n.isInteger()) {\n        return n.isNegative() || n.isZero() ? new _BigNumber(Infinity) : bigFactorial(n.minus(1));\n      }\n\n      if (!n.isFinite()) {\n        return new _BigNumber(n.isNegative() ? NaN : Infinity);\n      }\n\n      throw new Error('Integer BigNumber expected');\n    }\n  });\n  /**\r\n   * Calculate factorial for a BigNumber\r\n   * @param {BigNumber} n\r\n   * @returns {BigNumber} Returns the factorial of n\r\n   */\n\n  function bigFactorial(n) {\n    if (n < 8) {\n      return new _BigNumber([1, 1, 2, 6, 24, 120, 720, 5040][n]);\n    }\n\n    var precision = config.precision + (Math.log(n.toNumber()) | 0);\n\n    var Big = _BigNumber.clone({\n      precision\n    });\n\n    if (n % 2 === 1) {\n      return n.times(bigFactorial(new _BigNumber(n - 1)));\n    }\n\n    var p = n;\n    var prod = new Big(n);\n    var sum = n.toNumber();\n\n    while (p > 2) {\n      p -= 2;\n      sum += p;\n      prod = prod.times(sum);\n    }\n\n    return new _BigNumber(prod.toPrecision(_BigNumber.precision));\n  }\n});","map":{"version":3,"sources":["C:/Users/amase/Desktop/open_dsa/openDSA_dashboard/project/node_modules/mathjs/lib/esm/function/probability/gamma.js"],"names":["factory","gammaG","gammaNumber","gammaP","name","dependencies","createGamma","_ref","typed","config","multiplyScalar","pow","BigNumber","_BigNumber","Complex","gammaComplex","n","im","re","_t","r","Math","PI","div","sin","x","i","length","gammaPval","add","t","twoPiSqrt","sqrt","tpow","expt","neg","exp","mul","number","isInteger","isNegative","isZero","Infinity","bigFactorial","minus","isFinite","NaN","Error","precision","log","toNumber","Big","clone","times","p","prod","sum","toPrecision"],"mappings":"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","sourcesContent":["import { factory } from '../../utils/factory.js';\r\nimport { gammaG, gammaNumber, gammaP } from '../../plain/number/index.js';\r\nvar name = 'gamma';\r\nvar dependencies = ['typed', 'config', 'multiplyScalar', 'pow', 'BigNumber', 'Complex'];\r\nexport var createGamma = /* #__PURE__ */factory(name, dependencies, _ref => {\r\n  var {\r\n    typed,\r\n    config,\r\n    multiplyScalar,\r\n    pow,\r\n    BigNumber: _BigNumber,\r\n    Complex\r\n  } = _ref;\r\n  /**\r\n   * Compute the gamma function of a value using Lanczos approximation for\r\n   * small values, and an extended Stirling approximation for large values.\r\n   *\r\n   * To avoid confusion with the matrix Gamma function, this function does\r\n   * not apply to matrices.\r\n   *\r\n   * Syntax:\r\n   *\r\n   *    math.gamma(n)\r\n   *\r\n   * Examples:\r\n   *\r\n   *    math.gamma(5)       // returns 24\r\n   *    math.gamma(-0.5)    // returns -3.5449077018110335\r\n   *    math.gamma(math.i)  // returns -0.15494982830180973 - 0.49801566811835596i\r\n   *\r\n   * See also:\r\n   *\r\n   *    combinations, factorial, permutations\r\n   *\r\n   * @param {number | BigNumber | Complex} n   A real or complex number\r\n   * @return {number | BigNumber | Complex}    The gamma of `n`\r\n   */\r\n\r\n  function gammaComplex(n) {\r\n    if (n.im === 0) {\r\n      return gammaNumber(n.re);\r\n    }\r\n\r\n    // Lanczos approximation doesn't work well with real part lower than 0.5\r\n    // So reflection formula is required\r\n    if (n.re < 0.5) {\r\n      // Euler's reflection formula\r\n      // gamma(1-z) * gamma(z) = PI / sin(PI * z)\r\n      // real part of Z should not be integer [sin(PI) == 0 -> 1/0 - undefined]\r\n      // thanks to imperfect sin implementation sin(PI * n) != 0\r\n      // we can safely use it anyway\r\n      var _t = new Complex(1 - n.re, -n.im);\r\n      var r = new Complex(Math.PI * n.re, Math.PI * n.im);\r\n      return new Complex(Math.PI).div(r.sin()).div(gammaComplex(_t));\r\n    }\r\n\r\n    // Lanczos approximation\r\n    // z -= 1\r\n    n = new Complex(n.re - 1, n.im);\r\n\r\n    // x = gammaPval[0]\r\n    var x = new Complex(gammaP[0], 0);\r\n    // for (i, gammaPval) in enumerate(gammaP):\r\n    for (var i = 1; i < gammaP.length; ++i) {\r\n      // x += gammaPval / (z + i)\r\n      var gammaPval = new Complex(gammaP[i], 0);\r\n      x = x.add(gammaPval.div(n.add(i)));\r\n    }\r\n    // t = z + gammaG + 0.5\r\n    var t = new Complex(n.re + gammaG + 0.5, n.im);\r\n\r\n    // y = sqrt(2 * pi) * t ** (z + 0.5) * exp(-t) * x\r\n    var twoPiSqrt = Math.sqrt(2 * Math.PI);\r\n    var tpow = t.pow(n.add(0.5));\r\n    var expt = t.neg().exp();\r\n\r\n    // y = [x] * [sqrt(2 * pi)] * [t ** (z + 0.5)] * [exp(-t)]\r\n    return x.mul(twoPiSqrt).mul(tpow).mul(expt);\r\n  }\r\n  return typed(name, {\r\n    number: gammaNumber,\r\n    Complex: gammaComplex,\r\n    BigNumber: function BigNumber(n) {\r\n      if (n.isInteger()) {\r\n        return n.isNegative() || n.isZero() ? new _BigNumber(Infinity) : bigFactorial(n.minus(1));\r\n      }\r\n      if (!n.isFinite()) {\r\n        return new _BigNumber(n.isNegative() ? NaN : Infinity);\r\n      }\r\n      throw new Error('Integer BigNumber expected');\r\n    }\r\n  });\r\n\r\n  /**\r\n   * Calculate factorial for a BigNumber\r\n   * @param {BigNumber} n\r\n   * @returns {BigNumber} Returns the factorial of n\r\n   */\r\n  function bigFactorial(n) {\r\n    if (n < 8) {\r\n      return new _BigNumber([1, 1, 2, 6, 24, 120, 720, 5040][n]);\r\n    }\r\n    var precision = config.precision + (Math.log(n.toNumber()) | 0);\r\n    var Big = _BigNumber.clone({\r\n      precision\r\n    });\r\n    if (n % 2 === 1) {\r\n      return n.times(bigFactorial(new _BigNumber(n - 1)));\r\n    }\r\n    var p = n;\r\n    var prod = new Big(n);\r\n    var sum = n.toNumber();\r\n    while (p > 2) {\r\n      p -= 2;\r\n      sum += p;\r\n      prod = prod.times(sum);\r\n    }\r\n    return new _BigNumber(prod.toPrecision(_BigNumber.precision));\r\n  }\r\n});"]},"metadata":{},"sourceType":"module"}