{"ast":null,"code":"import { PdfString } from './../../primitives/pdf-string';\nimport { ArabicShapeRenderer } from './rtl/rtl-text-shape';\nimport { PdfTextDirection } from './../enum';\nimport { Bidi } from './rtl/rtl-bidirectional';\n/**\r\n * `Metrics` of the font.\r\n * @private\r\n */\n\nvar RtlRenderer =\n/** @class */\nfunction () {\n  function RtlRenderer() {\n    //region Constants\n    /// Open bracket symbol.\n    /// </summary>\n    this.openBracket = '('; /// <summary>\n    /// Close bracket symbol.\n    /// </summary>\n\n    this.closeBracket = ')'; //#endregion\n  } //#region Constructors\n  /// <summary>\n  /// Initializes a new instance of the <see cref=\"RtlRenderer\"/> class.\n  /// </summary>\n  // public constructor() {\n  // }\n  //#region Public Methods\n  /// <summary>\n  /// Layouts text. Changes blocks position in the RTL text.\n  /// Ligates the text if needed.\n  /// </summary>\n  /// <param name=\"line\">Line of the text.</param>\n  /// <param name=\"font\">Font to be used for string printing.</param>\n  /// <param name=\"rtl\">Font alignment.</param>\n  /// <param name=\"wordSpace\">Indicates whether Word Spacing used or not.</param>\n  /// <returns>Layout string.</returns>\n\n\n  RtlRenderer.prototype.layout = function (line, font, rtl, wordSpace, format) {\n    if (line == null) {\n      throw new Error('ArgumentNullException : line');\n    }\n\n    if (font == null) {\n      throw new Error('ArgumentNullException : font');\n    }\n\n    var result = [];\n\n    if (font.Unicode) {\n      result = this.customLayout(line, rtl, format, font, wordSpace);\n    } else {\n      result = [];\n      result[0] = line;\n    }\n\n    return result;\n  }; /// <summary>\n  /// Layouts a string and splits it by the words and using correct lay outing.\n  /// </summary>\n  /// <param name=\"line\">Text line.</param>\n  /// <param name=\"font\">Font object.</param>\n  /// <param name=\"rtl\">Indicates whether RTL should be applied.</param>\n  /// <param name=\"wordSpace\">Indicates whether word spacing is used.</param>\n  /// <returns>Array of words if converted, null otherwise.</returns>\n\n\n  RtlRenderer.prototype.splitLayout = function (line, font, rtl, wordSpace, format) {\n    if (line == null) {\n      throw new Error('ArgumentNullException : line');\n    }\n\n    if (font == null) {\n      throw new Error('ArgumentNullException : font');\n    }\n\n    var words = [];\n    var system = false;\n\n    if (!system || words == null) {\n      words = this.customSplitLayout(line, font, rtl, wordSpace, format);\n    }\n\n    return words;\n  }; //#endregion\n  //#region Implementation\n  // private isEnglish( word : string) : boolean\n  // {\n  //     let c : string = (word.length > 0) ? word[0] : '';\n  //     return (c >= '0' && c < 'Ã¿');\n  // }\n  // private keepOrder( words : string, startIndex : number, count: number, result : string[], resultIndex : number) : void\n  // {\n  //     for (let i : number = 0, ri = resultIndex - count + 1; i < count; ++i, ++ri) {\n  //         result[ri] = words[i + startIndex];\n  //     }\n  // }\n  /// <summary>\n  /// Uses system API to layout the text.\n  /// </summary>\n  /// <param name=\"line\">Line of the text to be layouted.</param>\n  /// <param name=\"font\">Font which is used for text printing.</param>\n  /// <param name=\"rtl\">Indicates whether we use RTL or RTL lay outing of the text container.</param>\n  /// <returns>Layout string.</returns>\n\n  /* tslint:disable-next-line:max-line-length */\n\n\n  RtlRenderer.prototype.getGlyphIndex = function (line, font, rtl,\n  /*out*/\n  glyphs, custom) {\n    var success = true;\n    var fail = false;\n\n    if (line == null) {\n      throw new Error('ArgumentNullException : line');\n    }\n\n    if (font == null) {\n      throw new Error('ArgumentNullException : font');\n    }\n\n    glyphs = null;\n\n    if (line.length === 0) {\n      return {\n        success: fail,\n        glyphs: glyphs\n      };\n    }\n\n    var renderer = new ArabicShapeRenderer();\n    var text = renderer.shape(line, 0);\n    var internalFont = font.fontInternal;\n    var ttfReader = internalFont.ttfReader;\n    glyphs = new Uint16Array(text.length);\n    var i = 0;\n\n    for (var k = 0, len = text.length; k < len; k++) {\n      var ch = text[k];\n      var glyphInfo = ttfReader.getGlyph(ch);\n\n      if (glyphInfo !== null && typeof glyphInfo !== 'undefined') {\n        glyphs[i++] = glyphInfo.index;\n      }\n    }\n\n    return {\n      success: success,\n      glyphs: glyphs\n    };\n  };\n  /* tslint:disable-next-line:max-line-length */\n\n\n  RtlRenderer.prototype.customLayout = function (line, rtl, format, font, wordSpace) {\n    if (wordSpace === null || typeof wordSpace === 'undefined') {\n      if (line == null) {\n        throw new Error('ArgumentNullException : line');\n      }\n\n      var result = null; //bidirectional order.\n\n      if (format !== null && typeof format !== 'undefined' && format.textDirection !== PdfTextDirection.None) {\n        var bidi = new Bidi();\n        result = bidi.getLogicalToVisualString(line, rtl);\n      }\n\n      return result;\n    } else {\n      if (line == null) {\n        throw new Error('ArgumentNullException : line');\n      }\n\n      if (font == null) {\n        throw new Error('ArgumentNullException : font');\n      }\n\n      var layouted = null;\n\n      if (format !== null && typeof format !== 'undefined' && format.textDirection !== PdfTextDirection.None) {\n        var renderer = new ArabicShapeRenderer();\n        var txt = renderer.shape(line, 0);\n        layouted = this.customLayout(txt, rtl, format);\n      } // else {\n      //     layouted = this.customLayout(line, rtl, format);\n      // }\n      // We have unicode font, but from the file.        \n\n\n      var result = []; // Split the text by words if word spacing is not default.\n\n      if (wordSpace) {\n        var words = layouted.split('');\n        var count = words.length;\n\n        for (var i = 0; i < count; i++) {\n          words[i] = this.addChars(font, words[i]);\n        }\n\n        result = words;\n      } else {\n        result = [];\n        result[0] = this.addChars(font, layouted);\n      }\n\n      return result;\n    }\n  }; /// <summary>\n  /// Add information about used glyphs to the font.\n  /// </summary>\n  /// <param name=\"font\">Font used for text rendering.</param>\n  /// <param name=\"glyphs\">Array of used glyphs.</param>\n  /// <returns>String in the form to be written to the file.</returns>\n\n\n  RtlRenderer.prototype.addChars = function (font, glyphs) {\n    var line = glyphs;\n\n    if (font == null) {\n      throw new Error('ArgumentNullException : font');\n    }\n\n    if (line == null) {\n      throw new Error('ArgumentNullException : line');\n    }\n\n    var text = line;\n    var internalFont = font.fontInternal;\n    var ttfReader = internalFont.ttfReader;\n    font.setSymbols(text); // Reconvert string according to unicode standard.\n\n    text = ttfReader.convertString(text);\n    var bytes = PdfString.toUnicodeArray(text, false);\n    text = PdfString.byteToString(bytes);\n    return text; // else {\n    //     if (font == null) {\n    //         throw new Error('ArgumentNullException : font');\n    //     }\n    //     if (glyphs == null) {\n    //         throw new Error('ArgumentNullException : glyphs');\n    //     }\n    //     // Mark the chars as used.\n    //     let text : string = '';\n    //     font.setSymbols(glyphs);\n    //     // Create string from the glyphs.\n    //     \n    //     let chars : string[] = [];\n    //     for (let i : number = 0; i < glyphs.length; i++) {\n    //         chars[i] = glyphs[i].toString();\n    //     }\n    //     for (let j : number = 0 ; j < chars.length; j++) {\n    //         text = text + chars[j];\n    //     }\n    //     let bytes : number[] = PdfString.toUnicodeArray(text, false);\n    //     text = PdfString.byteToString(bytes);\n    //     return text;\n    // }\n  }; /// <summary>\n  /// Layouts a string and splits it by the words by using custom lay outing.\n  /// </summary>\n  /// <param name=\"line\">Text line.</param>\n  /// <param name=\"font\">Font object.</param>\n  /// <param name=\"rtl\">Indicates whether RTL should be applied.</param>\n  /// <param name=\"wordSpace\">Indicates whether word spacing is used.</param>\n  /// <returns>Array of words if converted, null otherwise.</returns>\n\n  /* tslint:disable-next-line:max-line-length */\n\n\n  RtlRenderer.prototype.customSplitLayout = function (line, font, rtl, wordSpace, format) {\n    if (line == null) {\n      throw new Error('ArgumentNullException : line');\n    }\n\n    if (font == null) {\n      throw new Error('ArgumentNullException : font');\n    }\n\n    var reversedLine = this.customLayout(line, rtl, format);\n    var words = reversedLine.split('');\n    return words;\n  };\n\n  return RtlRenderer;\n}();\n\nexport { RtlRenderer };","map":{"version":3,"sources":["C:/Users/amase/Desktop/open_dsa/openDSA_dashboard/project/node_modules/@syncfusion/ej2-react-grids/node_modules/@syncfusion/ej2-pdf-export/src/implementation/graphics/fonts/rtl-renderer.js"],"names":["PdfString","ArabicShapeRenderer","PdfTextDirection","Bidi","RtlRenderer","openBracket","closeBracket","prototype","layout","line","font","rtl","wordSpace","format","Error","result","Unicode","customLayout","splitLayout","words","system","customSplitLayout","getGlyphIndex","glyphs","custom","success","fail","length","renderer","text","shape","internalFont","fontInternal","ttfReader","Uint16Array","i","k","len","ch","glyphInfo","getGlyph","index","textDirection","None","bidi","getLogicalToVisualString","layouted","txt","split","count","addChars","setSymbols","convertString","bytes","toUnicodeArray","byteToString","reversedLine"],"mappings":"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","sourcesContent":["import { PdfString } from './../../primitives/pdf-string';\r\nimport { ArabicShapeRenderer } from './rtl/rtl-text-shape';\r\nimport { PdfTextDirection } from './../enum';\r\nimport { Bidi } from './rtl/rtl-bidirectional';\r\n/**\r\n * `Metrics` of the font.\r\n * @private\r\n */\r\nvar RtlRenderer = /** @class */ (function () {\r\n    function RtlRenderer() {\r\n        //region Constants\r\n        /// Open bracket symbol.\r\n        /// </summary>\r\n        this.openBracket = '(';\r\n        /// <summary>\r\n        /// Close bracket symbol.\r\n        /// </summary>\r\n        this.closeBracket = ')';\r\n        //#endregion\r\n    }\r\n    //#region Constructors\r\n    /// <summary>\r\n    /// Initializes a new instance of the <see cref=\"RtlRenderer\"/> class.\r\n    /// </summary>\r\n    // public constructor() {\r\n    // }\r\n    //#region Public Methods\r\n    /// <summary>\r\n    /// Layouts text. Changes blocks position in the RTL text.\r\n    /// Ligates the text if needed.\r\n    /// </summary>\r\n    /// <param name=\"line\">Line of the text.</param>\r\n    /// <param name=\"font\">Font to be used for string printing.</param>\r\n    /// <param name=\"rtl\">Font alignment.</param>\r\n    /// <param name=\"wordSpace\">Indicates whether Word Spacing used or not.</param>\r\n    /// <returns>Layout string.</returns>\r\n    RtlRenderer.prototype.layout = function (line, font, rtl, wordSpace, format) {\r\n        if (line == null) {\r\n            throw new Error('ArgumentNullException : line');\r\n        }\r\n        if (font == null) {\r\n            throw new Error('ArgumentNullException : font');\r\n        }\r\n        var result = [];\r\n        if (font.Unicode) {\r\n            result = this.customLayout(line, rtl, format, font, wordSpace);\r\n        }\r\n        else {\r\n            result = [];\r\n            result[0] = line;\r\n        }\r\n        return result;\r\n    };\r\n    /// <summary>\r\n    /// Layouts a string and splits it by the words and using correct lay outing.\r\n    /// </summary>\r\n    /// <param name=\"line\">Text line.</param>\r\n    /// <param name=\"font\">Font object.</param>\r\n    /// <param name=\"rtl\">Indicates whether RTL should be applied.</param>\r\n    /// <param name=\"wordSpace\">Indicates whether word spacing is used.</param>\r\n    /// <returns>Array of words if converted, null otherwise.</returns>\r\n    RtlRenderer.prototype.splitLayout = function (line, font, rtl, wordSpace, format) {\r\n        if (line == null) {\r\n            throw new Error('ArgumentNullException : line');\r\n        }\r\n        if (font == null) {\r\n            throw new Error('ArgumentNullException : font');\r\n        }\r\n        var words = [];\r\n        var system = false;\r\n        if (!system || words == null) {\r\n            words = this.customSplitLayout(line, font, rtl, wordSpace, format);\r\n        }\r\n        return words;\r\n    };\r\n    //#endregion\r\n    //#region Implementation\r\n    // private isEnglish( word : string) : boolean\r\n    // {\r\n    //     let c : string = (word.length > 0) ? word[0] : '';\r\n    //     return (c >= '0' && c < 'Ã¿');\r\n    // }\r\n    // private keepOrder( words : string, startIndex : number, count: number, result : string[], resultIndex : number) : void\r\n    // {\r\n    //     for (let i : number = 0, ri = resultIndex - count + 1; i < count; ++i, ++ri) {\r\n    //         result[ri] = words[i + startIndex];\r\n    //     }\r\n    // }\r\n    /// <summary>\r\n    /// Uses system API to layout the text.\r\n    /// </summary>\r\n    /// <param name=\"line\">Line of the text to be layouted.</param>\r\n    /// <param name=\"font\">Font which is used for text printing.</param>\r\n    /// <param name=\"rtl\">Indicates whether we use RTL or RTL lay outing of the text container.</param>\r\n    /// <returns>Layout string.</returns>\r\n    /* tslint:disable-next-line:max-line-length */\r\n    RtlRenderer.prototype.getGlyphIndex = function (line, font, rtl, /*out*/ glyphs, custom) {\r\n        var success = true;\r\n        var fail = false;\r\n        if (line == null) {\r\n            throw new Error('ArgumentNullException : line');\r\n        }\r\n        if (font == null) {\r\n            throw new Error('ArgumentNullException : font');\r\n        }\r\n        glyphs = null;\r\n        if (line.length === 0) {\r\n            return { success: fail, glyphs: glyphs };\r\n        }\r\n        var renderer = new ArabicShapeRenderer();\r\n        var text = renderer.shape(line, 0);\r\n        var internalFont = font.fontInternal;\r\n        var ttfReader = internalFont.ttfReader;\r\n        glyphs = new Uint16Array(text.length);\r\n        var i = 0;\r\n        for (var k = 0, len = text.length; k < len; k++) {\r\n            var ch = text[k];\r\n            var glyphInfo = ttfReader.getGlyph(ch);\r\n            if (glyphInfo !== null && typeof glyphInfo !== 'undefined') {\r\n                glyphs[i++] = (glyphInfo).index;\r\n            }\r\n        }\r\n        return { success: success, glyphs: glyphs };\r\n    };\r\n    /* tslint:disable-next-line:max-line-length */\r\n    RtlRenderer.prototype.customLayout = function (line, rtl, format, font, wordSpace) {\r\n        if (wordSpace === null || typeof wordSpace === 'undefined') {\r\n            if (line == null) {\r\n                throw new Error('ArgumentNullException : line');\r\n            }\r\n            var result = null;\r\n            //bidirectional order.\r\n            if (format !== null && typeof format !== 'undefined' && format.textDirection !== PdfTextDirection.None) {\r\n                var bidi = new Bidi();\r\n                result = bidi.getLogicalToVisualString(line, rtl);\r\n            }\r\n            return result;\r\n        }\r\n        else {\r\n            if (line == null) {\r\n                throw new Error('ArgumentNullException : line');\r\n            }\r\n            if (font == null) {\r\n                throw new Error('ArgumentNullException : font');\r\n            }\r\n            var layouted = null;\r\n            if (format !== null && typeof format !== 'undefined' && format.textDirection !== PdfTextDirection.None) {\r\n                var renderer = new ArabicShapeRenderer();\r\n                var txt = renderer.shape(line, 0);\r\n                layouted = this.customLayout(txt, rtl, format);\r\n            }\r\n            // else {\r\n            //     layouted = this.customLayout(line, rtl, format);\r\n            // }\r\n            // We have unicode font, but from the file.        \r\n            var result = [];\r\n            // Split the text by words if word spacing is not default.\r\n            if (wordSpace) {\r\n                var words = layouted.split('');\r\n                var count = words.length;\r\n                for (var i = 0; i < count; i++) {\r\n                    words[i] = this.addChars(font, words[i]);\r\n                }\r\n                result = words;\r\n            }\r\n            else {\r\n                result = [];\r\n                result[0] = this.addChars(font, layouted);\r\n            }\r\n            return result;\r\n        }\r\n    };\r\n    /// <summary>\r\n    /// Add information about used glyphs to the font.\r\n    /// </summary>\r\n    /// <param name=\"font\">Font used for text rendering.</param>\r\n    /// <param name=\"glyphs\">Array of used glyphs.</param>\r\n    /// <returns>String in the form to be written to the file.</returns>\r\n    RtlRenderer.prototype.addChars = function (font, glyphs) {\r\n        var line = glyphs;\r\n        if (font == null) {\r\n            throw new Error('ArgumentNullException : font');\r\n        }\r\n        if (line == null) {\r\n            throw new Error('ArgumentNullException : line');\r\n        }\r\n        var text = line;\r\n        var internalFont = font.fontInternal;\r\n        var ttfReader = internalFont.ttfReader;\r\n        font.setSymbols(text);\r\n        // Reconvert string according to unicode standard.\r\n        text = ttfReader.convertString(text);\r\n        var bytes = PdfString.toUnicodeArray(text, false);\r\n        text = PdfString.byteToString(bytes);\r\n        return text;\r\n        // else {\r\n        //     if (font == null) {\r\n        //         throw new Error('ArgumentNullException : font');\r\n        //     }\r\n        //     if (glyphs == null) {\r\n        //         throw new Error('ArgumentNullException : glyphs');\r\n        //     }\r\n        //     // Mark the chars as used.\r\n        //     let text : string = '';\r\n        //     font.setSymbols(glyphs);\r\n        //     // Create string from the glyphs.\r\n        //     \r\n        //     let chars : string[] = [];\r\n        //     for (let i : number = 0; i < glyphs.length; i++) {\r\n        //         chars[i] = glyphs[i].toString();\r\n        //     }\r\n        //     for (let j : number = 0 ; j < chars.length; j++) {\r\n        //         text = text + chars[j];\r\n        //     }\r\n        //     let bytes : number[] = PdfString.toUnicodeArray(text, false);\r\n        //     text = PdfString.byteToString(bytes);\r\n        //     return text;\r\n        // }\r\n    };\r\n    /// <summary>\r\n    /// Layouts a string and splits it by the words by using custom lay outing.\r\n    /// </summary>\r\n    /// <param name=\"line\">Text line.</param>\r\n    /// <param name=\"font\">Font object.</param>\r\n    /// <param name=\"rtl\">Indicates whether RTL should be applied.</param>\r\n    /// <param name=\"wordSpace\">Indicates whether word spacing is used.</param>\r\n    /// <returns>Array of words if converted, null otherwise.</returns>\r\n    /* tslint:disable-next-line:max-line-length */\r\n    RtlRenderer.prototype.customSplitLayout = function (line, font, rtl, wordSpace, format) {\r\n        if (line == null) {\r\n            throw new Error('ArgumentNullException : line');\r\n        }\r\n        if (font == null) {\r\n            throw new Error('ArgumentNullException : font');\r\n        }\r\n        var reversedLine = this.customLayout(line, rtl, format);\r\n        var words = reversedLine.split('');\r\n        return words;\r\n    };\r\n    return RtlRenderer;\r\n}());\r\nexport { RtlRenderer };\r\n"]},"metadata":{},"sourceType":"module"}