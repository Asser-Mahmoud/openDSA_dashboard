{"ast":null,"code":"import { csReach } from './csReach.js';\nimport { factory } from '../../../utils/factory.js';\nvar name = 'csSpsolve';\nvar dependencies = ['divideScalar', 'multiply', 'subtract'];\nexport var createCsSpsolve = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    divideScalar,\n    multiply,\n    subtract\n  } = _ref;\n  /**\r\n   * The function csSpsolve() computes the solution to G * x = bk, where bk is the\r\n   * kth column of B. When lo is true, the function assumes G = L is lower triangular with the\r\n   * diagonal entry as the first entry in each column. When lo is true, the function assumes G = U\r\n   * is upper triangular with the diagonal entry as the last entry in each column.\r\n   *\r\n   * @param {Matrix}  g               The G matrix\r\n   * @param {Matrix}  b               The B matrix\r\n   * @param {Number}  k               The kth column in B\r\n   * @param {Array}   xi              The nonzero pattern xi[top] .. xi[n - 1], an array of size = 2 * n\r\n   *                                  The first n entries is the nonzero pattern, the last n entries is the stack\r\n   * @param {Array}   x               The soluton to the linear system G * x = b\r\n   * @param {Array}   pinv            The inverse row permutation vector, must be null for L * x = b\r\n   * @param {boolean} lo              The lower (true) upper triangular (false) flag\r\n   *\r\n   * @return {Number}                 The index for the nonzero pattern\r\n   *\r\n   * Reference: http://faculty.cse.tamu.edu/davis/publications.html\r\n   */\n\n  return function csSpsolve(g, b, k, xi, x, pinv, lo) {\n    // g arrays\n    var gvalues = g._values;\n    var gindex = g._index;\n    var gptr = g._ptr;\n    var gsize = g._size; // columns\n\n    var n = gsize[1]; // b arrays\n\n    var bvalues = b._values;\n    var bindex = b._index;\n    var bptr = b._ptr; // vars\n\n    var p, p0, p1, q; // xi[top..n-1] = csReach(B(:,k))\n\n    var top = csReach(g, b, k, xi, pinv); // clear x\n\n    for (p = top; p < n; p++) {\n      x[xi[p]] = 0;\n    } // scatter b\n\n\n    for (p0 = bptr[k], p1 = bptr[k + 1], p = p0; p < p1; p++) {\n      x[bindex[p]] = bvalues[p];\n    } // loop columns\n\n\n    for (var px = top; px < n; px++) {\n      // x array index for px\n      var j = xi[px]; // apply permutation vector (U x = b), j maps to column J of G\n\n      var J = pinv ? pinv[j] : j; // check column J is empty\n\n      if (J < 0) {\n        continue;\n      } // column value indeces in G, p0 <= p < p1\n\n\n      p0 = gptr[J];\n      p1 = gptr[J + 1]; // x(j) /= G(j,j)\n\n      x[j] = divideScalar(x[j], gvalues[lo ? p0 : p1 - 1]); // first entry L(j,j)\n\n      p = lo ? p0 + 1 : p0;\n      q = lo ? p1 : p1 - 1; // loop\n\n      for (; p < q; p++) {\n        // row\n        var i = gindex[p]; // x(i) -= G(i,j) * x(j)\n\n        x[i] = subtract(x[i], multiply(gvalues[p], x[j]));\n      }\n    } // return top of stack\n\n\n    return top;\n  };\n});","map":{"version":3,"sources":["C:/Users/x/Desktop/openDSA/openDSA_dashboard/project/node_modules/mathjs/lib/esm/function/algebra/sparse/csSpsolve.js"],"names":["csReach","factory","name","dependencies","createCsSpsolve","_ref","divideScalar","multiply","subtract","csSpsolve","g","b","k","xi","x","pinv","lo","gvalues","_values","gindex","_index","gptr","_ptr","gsize","_size","n","bvalues","bindex","bptr","p","p0","p1","q","top","px","j","J","i"],"mappings":"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","sourcesContent":["import { csReach } from './csReach.js';\r\nimport { factory } from '../../../utils/factory.js';\r\nvar name = 'csSpsolve';\r\nvar dependencies = ['divideScalar', 'multiply', 'subtract'];\r\nexport var createCsSpsolve = /* #__PURE__ */factory(name, dependencies, _ref => {\r\n  var {\r\n    divideScalar,\r\n    multiply,\r\n    subtract\r\n  } = _ref;\r\n  /**\r\n   * The function csSpsolve() computes the solution to G * x = bk, where bk is the\r\n   * kth column of B. When lo is true, the function assumes G = L is lower triangular with the\r\n   * diagonal entry as the first entry in each column. When lo is true, the function assumes G = U\r\n   * is upper triangular with the diagonal entry as the last entry in each column.\r\n   *\r\n   * @param {Matrix}  g               The G matrix\r\n   * @param {Matrix}  b               The B matrix\r\n   * @param {Number}  k               The kth column in B\r\n   * @param {Array}   xi              The nonzero pattern xi[top] .. xi[n - 1], an array of size = 2 * n\r\n   *                                  The first n entries is the nonzero pattern, the last n entries is the stack\r\n   * @param {Array}   x               The soluton to the linear system G * x = b\r\n   * @param {Array}   pinv            The inverse row permutation vector, must be null for L * x = b\r\n   * @param {boolean} lo              The lower (true) upper triangular (false) flag\r\n   *\r\n   * @return {Number}                 The index for the nonzero pattern\r\n   *\r\n   * Reference: http://faculty.cse.tamu.edu/davis/publications.html\r\n   */\r\n  return function csSpsolve(g, b, k, xi, x, pinv, lo) {\r\n    // g arrays\r\n    var gvalues = g._values;\r\n    var gindex = g._index;\r\n    var gptr = g._ptr;\r\n    var gsize = g._size;\r\n    // columns\r\n    var n = gsize[1];\r\n    // b arrays\r\n    var bvalues = b._values;\r\n    var bindex = b._index;\r\n    var bptr = b._ptr;\r\n    // vars\r\n    var p, p0, p1, q;\r\n    // xi[top..n-1] = csReach(B(:,k))\r\n    var top = csReach(g, b, k, xi, pinv);\r\n    // clear x\r\n    for (p = top; p < n; p++) {\r\n      x[xi[p]] = 0;\r\n    }\r\n    // scatter b\r\n    for (p0 = bptr[k], p1 = bptr[k + 1], p = p0; p < p1; p++) {\r\n      x[bindex[p]] = bvalues[p];\r\n    }\r\n    // loop columns\r\n    for (var px = top; px < n; px++) {\r\n      // x array index for px\r\n      var j = xi[px];\r\n      // apply permutation vector (U x = b), j maps to column J of G\r\n      var J = pinv ? pinv[j] : j;\r\n      // check column J is empty\r\n      if (J < 0) {\r\n        continue;\r\n      }\r\n      // column value indeces in G, p0 <= p < p1\r\n      p0 = gptr[J];\r\n      p1 = gptr[J + 1];\r\n      // x(j) /= G(j,j)\r\n      x[j] = divideScalar(x[j], gvalues[lo ? p0 : p1 - 1]);\r\n      // first entry L(j,j)\r\n      p = lo ? p0 + 1 : p0;\r\n      q = lo ? p1 : p1 - 1;\r\n      // loop\r\n      for (; p < q; p++) {\r\n        // row\r\n        var i = gindex[p];\r\n        // x(i) -= G(i,j) * x(j)\r\n        x[i] = subtract(x[i], multiply(gvalues[p], x[j]));\r\n      }\r\n    }\r\n    // return top of stack\r\n    return top;\r\n  };\r\n});"]},"metadata":{},"sourceType":"module"}