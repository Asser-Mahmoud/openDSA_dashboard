{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport { isNode } from '../../utils/is.js';\nimport { keywords } from '../keywords.js';\nimport { escape } from '../../utils/string.js';\nimport { forEach, join } from '../../utils/array.js';\nimport { toSymbol } from '../../utils/latex.js';\nimport { getPrecedence } from '../operators.js';\nimport { factory } from '../../utils/factory.js';\nvar name = 'FunctionAssignmentNode';\nvar dependencies = ['typed', 'Node'];\nexport var createFunctionAssignmentNode = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    Node\n  } = _ref;\n  /**\r\n   * Is parenthesis needed?\r\n   * @param {Node} node\r\n   * @param {Object} parenthesis\r\n   * @param {string} implicit\r\n   * @private\r\n   */\n\n  function needParenthesis(node, parenthesis, implicit) {\n    var precedence = getPrecedence(node, parenthesis, implicit);\n    var exprPrecedence = getPrecedence(node.expr, parenthesis, implicit);\n    return parenthesis === 'all' || exprPrecedence !== null && exprPrecedence <= precedence;\n  }\n\n  class FunctionAssignmentNode extends Node {\n    /**\r\n     * @constructor FunctionAssignmentNode\r\n     * @extends {Node}\r\n     * Function assignment\r\n     *\r\n     * @param {string} name           Function name\r\n     * @param {string[] | Array.<{name: string, type: string}>} params\r\n     *                                Array with function parameter names, or an\r\n     *                                array with objects containing the name\r\n     *                                and type of the parameter\r\n     * @param {Node} expr             The function expression\r\n     */\n    constructor(name, params, expr) {\n      super(); // validate input\n\n      if (typeof name !== 'string') {\n        throw new TypeError('String expected for parameter \"name\"');\n      }\n\n      if (!Array.isArray(params)) {\n        throw new TypeError('Array containing strings or objects expected for parameter \"params\"');\n      }\n\n      if (!isNode(expr)) {\n        throw new TypeError('Node expected for parameter \"expr\"');\n      }\n\n      if (keywords.has(name)) {\n        throw new Error('Illegal function name, \"' + name + '\" is a reserved keyword');\n      }\n\n      var paramNames = new Set();\n\n      for (var param of params) {\n        var _name = typeof param === 'string' ? param : param.name;\n\n        if (paramNames.has(_name)) {\n          throw new Error(\"Duplicate parameter name \\\"\".concat(_name, \"\\\"\"));\n        } else {\n          paramNames.add(_name);\n        }\n      }\n\n      this.name = name;\n      this.params = params.map(function (param) {\n        return param && param.name || param;\n      });\n      this.types = params.map(function (param) {\n        return param && param.type || 'any';\n      });\n      this.expr = expr;\n    }\n\n    get type() {\n      return name;\n    }\n\n    get isFunctionAssignmentNode() {\n      return true;\n    }\n    /**\r\n     * Compile a node into a JavaScript function.\r\n     * This basically pre-calculates as much as possible and only leaves open\r\n     * calculations which depend on a dynamic scope with variables.\r\n     * @param {Object} math     Math.js namespace with functions and constants.\r\n     * @param {Object} argNames An object with argument names as key and `true`\r\n     *                          as value. Used in the SymbolNode to optimize\r\n     *                          for arguments from user assigned functions\r\n     *                          (see FunctionAssignmentNode) or special symbols\r\n     *                          like `end` (see IndexNode).\r\n     * @return {function} Returns a function which can be called like:\r\n     *                        evalNode(scope: Object, args: Object, context: *)\r\n     */\n\n\n    _compile(math, argNames) {\n      var childArgNames = Object.create(argNames);\n      forEach(this.params, function (param) {\n        childArgNames[param] = true;\n      }); // compile the function expression with the child args\n\n      var evalExpr = this.expr._compile(math, childArgNames);\n\n      var name = this.name;\n      var params = this.params;\n      var signature = join(this.types, ',');\n      var syntax = name + '(' + join(this.params, ', ') + ')';\n      return function evalFunctionAssignmentNode(scope, args, context) {\n        var signatures = {};\n\n        signatures[signature] = function () {\n          var childArgs = Object.create(args);\n\n          for (var i = 0; i < params.length; i++) {\n            childArgs[params[i]] = arguments[i];\n          }\n\n          return evalExpr(scope, childArgs, context);\n        };\n\n        var fn = typed(name, signatures);\n        fn.syntax = syntax;\n        scope.set(name, fn);\n        return fn;\n      };\n    }\n    /**\r\n     * Execute a callback for each of the child nodes of this node\r\n     * @param {function(child: Node, path: string, parent: Node)} callback\r\n     */\n\n\n    forEach(callback) {\n      callback(this.expr, 'expr', this);\n    }\n    /**\r\n     * Create a new FunctionAssignmentNode whose children are the results of\r\n     * calling the provided callback function for each child of the original\r\n     * node.\r\n     * @param {function(child: Node, path: string, parent: Node): Node} callback\r\n     * @returns {FunctionAssignmentNode} Returns a transformed copy of the node\r\n     */\n\n\n    map(callback) {\n      var expr = this._ifNode(callback(this.expr, 'expr', this));\n\n      return new FunctionAssignmentNode(this.name, this.params.slice(0), expr);\n    }\n    /**\r\n     * Create a clone of this node, a shallow copy\r\n     * @return {FunctionAssignmentNode}\r\n     */\n\n\n    clone() {\n      return new FunctionAssignmentNode(this.name, this.params.slice(0), this.expr);\n    }\n    /**\r\n     * get string representation\r\n     * @param {Object} options\r\n     * @return {string} str\r\n     */\n\n\n    _toString(options) {\n      var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n      var expr = this.expr.toString(options);\n\n      if (needParenthesis(this, parenthesis, options && options.implicit)) {\n        expr = '(' + expr + ')';\n      }\n\n      return this.name + '(' + this.params.join(', ') + ') = ' + expr;\n    }\n    /**\r\n     * Get a JSON representation of the node\r\n     * @returns {Object}\r\n     */\n\n\n    toJSON() {\n      var types = this.types;\n      return {\n        mathjs: name,\n        name: this.name,\n        params: this.params.map(function (param, index) {\n          return {\n            name: param,\n            type: types[index]\n          };\n        }),\n        expr: this.expr\n      };\n    }\n    /**\r\n     * Instantiate an FunctionAssignmentNode from its JSON representation\r\n     * @param {Object} json\r\n     *     An object structured like\r\n     *     ```\r\n     *     {\"mathjs\": \"FunctionAssignmentNode\",\r\n     *      name: ..., params: ..., expr: ...}\r\n     *     ```\r\n     *     where mathjs is optional\r\n     * @returns {FunctionAssignmentNode}\r\n     */\n\n\n    static fromJSON(json) {\n      return new FunctionAssignmentNode(json.name, json.params, json.expr);\n    }\n    /**\r\n     * get HTML representation\r\n     * @param {Object} options\r\n     * @return {string} str\r\n     */\n\n\n    toHTML(options) {\n      var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n      var params = [];\n\n      for (var i = 0; i < this.params.length; i++) {\n        params.push('<span class=\"math-symbol math-parameter\">' + escape(this.params[i]) + '</span>');\n      }\n\n      var expr = this.expr.toHTML(options);\n\n      if (needParenthesis(this, parenthesis, options && options.implicit)) {\n        expr = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + expr + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n      }\n\n      return '<span class=\"math-function\">' + escape(this.name) + '</span>' + '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + params.join('<span class=\"math-separator\">,</span>') + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>' + '<span class=\"math-operator math-assignment-operator ' + 'math-variable-assignment-operator math-binary-operator\">=</span>' + expr;\n    }\n    /**\r\n     * get LaTeX representation\r\n     * @param {Object} options\r\n     * @return {string} str\r\n     */\n\n\n    _toTex(options) {\n      var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n      var expr = this.expr.toTex(options);\n\n      if (needParenthesis(this, parenthesis, options && options.implicit)) {\n        expr = \"\\\\left(\".concat(expr, \"\\\\right)\");\n      }\n\n      return '\\\\mathrm{' + this.name + '}\\\\left(' + this.params.map(toSymbol).join(',') + '\\\\right):=' + expr;\n    }\n\n  }\n\n  _defineProperty(FunctionAssignmentNode, \"name\", name);\n\n  return FunctionAssignmentNode;\n}, {\n  isClass: true,\n  isNode: true\n});","map":{"version":3,"sources":["C:/Users/x/Desktop/openDSA/openDSA_dashboard/project/node_modules/mathjs/lib/esm/expression/node/FunctionAssignmentNode.js"],"names":["_defineProperty","isNode","keywords","escape","forEach","join","toSymbol","getPrecedence","factory","name","dependencies","createFunctionAssignmentNode","_ref","typed","Node","needParenthesis","node","parenthesis","implicit","precedence","exprPrecedence","expr","FunctionAssignmentNode","constructor","params","TypeError","Array","isArray","has","Error","paramNames","Set","param","_name","concat","add","map","types","type","isFunctionAssignmentNode","_compile","math","argNames","childArgNames","Object","create","evalExpr","signature","syntax","evalFunctionAssignmentNode","scope","args","context","signatures","childArgs","i","length","arguments","fn","set","callback","_ifNode","slice","clone","_toString","options","toString","toJSON","mathjs","index","fromJSON","json","toHTML","push","_toTex","toTex","isClass"],"mappings":"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","sourcesContent":["import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\r\nimport { isNode } from '../../utils/is.js';\r\nimport { keywords } from '../keywords.js';\r\nimport { escape } from '../../utils/string.js';\r\nimport { forEach, join } from '../../utils/array.js';\r\nimport { toSymbol } from '../../utils/latex.js';\r\nimport { getPrecedence } from '../operators.js';\r\nimport { factory } from '../../utils/factory.js';\r\nvar name = 'FunctionAssignmentNode';\r\nvar dependencies = ['typed', 'Node'];\r\nexport var createFunctionAssignmentNode = /* #__PURE__ */factory(name, dependencies, _ref => {\r\n  var {\r\n    typed,\r\n    Node\r\n  } = _ref;\r\n  /**\r\n   * Is parenthesis needed?\r\n   * @param {Node} node\r\n   * @param {Object} parenthesis\r\n   * @param {string} implicit\r\n   * @private\r\n   */\r\n  function needParenthesis(node, parenthesis, implicit) {\r\n    var precedence = getPrecedence(node, parenthesis, implicit);\r\n    var exprPrecedence = getPrecedence(node.expr, parenthesis, implicit);\r\n    return parenthesis === 'all' || exprPrecedence !== null && exprPrecedence <= precedence;\r\n  }\r\n  class FunctionAssignmentNode extends Node {\r\n    /**\r\n     * @constructor FunctionAssignmentNode\r\n     * @extends {Node}\r\n     * Function assignment\r\n     *\r\n     * @param {string} name           Function name\r\n     * @param {string[] | Array.<{name: string, type: string}>} params\r\n     *                                Array with function parameter names, or an\r\n     *                                array with objects containing the name\r\n     *                                and type of the parameter\r\n     * @param {Node} expr             The function expression\r\n     */\r\n    constructor(name, params, expr) {\r\n      super();\r\n      // validate input\r\n      if (typeof name !== 'string') {\r\n        throw new TypeError('String expected for parameter \"name\"');\r\n      }\r\n      if (!Array.isArray(params)) {\r\n        throw new TypeError('Array containing strings or objects expected for parameter \"params\"');\r\n      }\r\n      if (!isNode(expr)) {\r\n        throw new TypeError('Node expected for parameter \"expr\"');\r\n      }\r\n      if (keywords.has(name)) {\r\n        throw new Error('Illegal function name, \"' + name + '\" is a reserved keyword');\r\n      }\r\n      var paramNames = new Set();\r\n      for (var param of params) {\r\n        var _name = typeof param === 'string' ? param : param.name;\r\n        if (paramNames.has(_name)) {\r\n          throw new Error(\"Duplicate parameter name \\\"\".concat(_name, \"\\\"\"));\r\n        } else {\r\n          paramNames.add(_name);\r\n        }\r\n      }\r\n      this.name = name;\r\n      this.params = params.map(function (param) {\r\n        return param && param.name || param;\r\n      });\r\n      this.types = params.map(function (param) {\r\n        return param && param.type || 'any';\r\n      });\r\n      this.expr = expr;\r\n    }\r\n    get type() {\r\n      return name;\r\n    }\r\n    get isFunctionAssignmentNode() {\r\n      return true;\r\n    }\r\n\r\n    /**\r\n     * Compile a node into a JavaScript function.\r\n     * This basically pre-calculates as much as possible and only leaves open\r\n     * calculations which depend on a dynamic scope with variables.\r\n     * @param {Object} math     Math.js namespace with functions and constants.\r\n     * @param {Object} argNames An object with argument names as key and `true`\r\n     *                          as value. Used in the SymbolNode to optimize\r\n     *                          for arguments from user assigned functions\r\n     *                          (see FunctionAssignmentNode) or special symbols\r\n     *                          like `end` (see IndexNode).\r\n     * @return {function} Returns a function which can be called like:\r\n     *                        evalNode(scope: Object, args: Object, context: *)\r\n     */\r\n    _compile(math, argNames) {\r\n      var childArgNames = Object.create(argNames);\r\n      forEach(this.params, function (param) {\r\n        childArgNames[param] = true;\r\n      });\r\n\r\n      // compile the function expression with the child args\r\n      var evalExpr = this.expr._compile(math, childArgNames);\r\n      var name = this.name;\r\n      var params = this.params;\r\n      var signature = join(this.types, ',');\r\n      var syntax = name + '(' + join(this.params, ', ') + ')';\r\n      return function evalFunctionAssignmentNode(scope, args, context) {\r\n        var signatures = {};\r\n        signatures[signature] = function () {\r\n          var childArgs = Object.create(args);\r\n          for (var i = 0; i < params.length; i++) {\r\n            childArgs[params[i]] = arguments[i];\r\n          }\r\n          return evalExpr(scope, childArgs, context);\r\n        };\r\n        var fn = typed(name, signatures);\r\n        fn.syntax = syntax;\r\n        scope.set(name, fn);\r\n        return fn;\r\n      };\r\n    }\r\n\r\n    /**\r\n     * Execute a callback for each of the child nodes of this node\r\n     * @param {function(child: Node, path: string, parent: Node)} callback\r\n     */\r\n    forEach(callback) {\r\n      callback(this.expr, 'expr', this);\r\n    }\r\n\r\n    /**\r\n     * Create a new FunctionAssignmentNode whose children are the results of\r\n     * calling the provided callback function for each child of the original\r\n     * node.\r\n     * @param {function(child: Node, path: string, parent: Node): Node} callback\r\n     * @returns {FunctionAssignmentNode} Returns a transformed copy of the node\r\n     */\r\n    map(callback) {\r\n      var expr = this._ifNode(callback(this.expr, 'expr', this));\r\n      return new FunctionAssignmentNode(this.name, this.params.slice(0), expr);\r\n    }\r\n\r\n    /**\r\n     * Create a clone of this node, a shallow copy\r\n     * @return {FunctionAssignmentNode}\r\n     */\r\n    clone() {\r\n      return new FunctionAssignmentNode(this.name, this.params.slice(0), this.expr);\r\n    }\r\n\r\n    /**\r\n     * get string representation\r\n     * @param {Object} options\r\n     * @return {string} str\r\n     */\r\n    _toString(options) {\r\n      var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\r\n      var expr = this.expr.toString(options);\r\n      if (needParenthesis(this, parenthesis, options && options.implicit)) {\r\n        expr = '(' + expr + ')';\r\n      }\r\n      return this.name + '(' + this.params.join(', ') + ') = ' + expr;\r\n    }\r\n\r\n    /**\r\n     * Get a JSON representation of the node\r\n     * @returns {Object}\r\n     */\r\n    toJSON() {\r\n      var types = this.types;\r\n      return {\r\n        mathjs: name,\r\n        name: this.name,\r\n        params: this.params.map(function (param, index) {\r\n          return {\r\n            name: param,\r\n            type: types[index]\r\n          };\r\n        }),\r\n        expr: this.expr\r\n      };\r\n    }\r\n\r\n    /**\r\n     * Instantiate an FunctionAssignmentNode from its JSON representation\r\n     * @param {Object} json\r\n     *     An object structured like\r\n     *     ```\r\n     *     {\"mathjs\": \"FunctionAssignmentNode\",\r\n     *      name: ..., params: ..., expr: ...}\r\n     *     ```\r\n     *     where mathjs is optional\r\n     * @returns {FunctionAssignmentNode}\r\n     */\r\n    static fromJSON(json) {\r\n      return new FunctionAssignmentNode(json.name, json.params, json.expr);\r\n    }\r\n\r\n    /**\r\n     * get HTML representation\r\n     * @param {Object} options\r\n     * @return {string} str\r\n     */\r\n    toHTML(options) {\r\n      var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\r\n      var params = [];\r\n      for (var i = 0; i < this.params.length; i++) {\r\n        params.push('<span class=\"math-symbol math-parameter\">' + escape(this.params[i]) + '</span>');\r\n      }\r\n      var expr = this.expr.toHTML(options);\r\n      if (needParenthesis(this, parenthesis, options && options.implicit)) {\r\n        expr = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + expr + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\r\n      }\r\n      return '<span class=\"math-function\">' + escape(this.name) + '</span>' + '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + params.join('<span class=\"math-separator\">,</span>') + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>' + '<span class=\"math-operator math-assignment-operator ' + 'math-variable-assignment-operator math-binary-operator\">=</span>' + expr;\r\n    }\r\n\r\n    /**\r\n     * get LaTeX representation\r\n     * @param {Object} options\r\n     * @return {string} str\r\n     */\r\n    _toTex(options) {\r\n      var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\r\n      var expr = this.expr.toTex(options);\r\n      if (needParenthesis(this, parenthesis, options && options.implicit)) {\r\n        expr = \"\\\\left(\".concat(expr, \"\\\\right)\");\r\n      }\r\n      return '\\\\mathrm{' + this.name + '}\\\\left(' + this.params.map(toSymbol).join(',') + '\\\\right):=' + expr;\r\n    }\r\n  }\r\n  _defineProperty(FunctionAssignmentNode, \"name\", name);\r\n  return FunctionAssignmentNode;\r\n}, {\r\n  isClass: true,\r\n  isNode: true\r\n});"]},"metadata":{},"sourceType":"module"}