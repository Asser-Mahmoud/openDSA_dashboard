{"ast":null,"code":"import { clone } from '../../utils/object.js';\nimport { format } from '../../utils/string.js';\nimport { factory } from '../../utils/factory.js';\nvar name = 'transpose';\nvar dependencies = ['typed', 'matrix'];\nexport var createTranspose = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    matrix\n  } = _ref;\n  /**\r\n   * Transpose a matrix. All values of the matrix are reflected over its\r\n   * main diagonal. Only applicable to two dimensional matrices containing\r\n   * a vector (i.e. having size `[1,n]` or `[n,1]`). One dimensional\r\n   * vectors and scalars return the input unchanged.\r\n   *\r\n   * Syntax:\r\n   *\r\n   *     math.transpose(x)\r\n   *\r\n   * Examples:\r\n   *\r\n   *     const A = [[1, 2, 3], [4, 5, 6]]\r\n   *     math.transpose(A)               // returns [[1, 4], [2, 5], [3, 6]]\r\n   *\r\n   * See also:\r\n   *\r\n   *     diag, inv, subset, squeeze\r\n   *\r\n   * @param {Array | Matrix} x  Matrix to be transposed\r\n   * @return {Array | Matrix}   The transposed matrix\r\n   */\n\n  return typed(name, {\n    Array: x => transposeMatrix(matrix(x)).valueOf(),\n    Matrix: transposeMatrix,\n    any: clone // scalars\n\n  });\n\n  function transposeMatrix(x) {\n    // matrix size\n    var size = x.size(); // result\n\n    var c; // process dimensions\n\n    switch (size.length) {\n      case 1:\n        // vector\n        c = x.clone();\n        break;\n\n      case 2:\n        {\n          // rows and columns\n          var rows = size[0];\n          var columns = size[1]; // check columns\n\n          if (columns === 0) {\n            // throw exception\n            throw new RangeError('Cannot transpose a 2D matrix with no columns (size: ' + format(size) + ')');\n          } // process storage format\n\n\n          switch (x.storage()) {\n            case 'dense':\n              c = _denseTranspose(x, rows, columns);\n              break;\n\n            case 'sparse':\n              c = _sparseTranspose(x, rows, columns);\n              break;\n          }\n        }\n        break;\n\n      default:\n        // multi dimensional\n        throw new RangeError('Matrix must be a vector or two dimensional (size: ' + format(size) + ')');\n    }\n\n    return c;\n  }\n\n  function _denseTranspose(m, rows, columns) {\n    // matrix array\n    var data = m._data; // transposed matrix data\n\n    var transposed = [];\n    var transposedRow; // loop columns\n\n    for (var j = 0; j < columns; j++) {\n      // initialize row\n      transposedRow = transposed[j] = []; // loop rows\n\n      for (var i = 0; i < rows; i++) {\n        // set data\n        transposedRow[i] = clone(data[i][j]);\n      }\n    } // return matrix\n\n\n    return m.createDenseMatrix({\n      data: transposed,\n      size: [columns, rows],\n      datatype: m._datatype\n    });\n  }\n\n  function _sparseTranspose(m, rows, columns) {\n    // matrix arrays\n    var values = m._values;\n    var index = m._index;\n    var ptr = m._ptr; // result matrices\n\n    var cvalues = values ? [] : undefined;\n    var cindex = [];\n    var cptr = []; // row counts\n\n    var w = [];\n\n    for (var x = 0; x < rows; x++) {\n      w[x] = 0;\n    } // vars\n\n\n    var p, l, j; // loop values in matrix\n\n    for (p = 0, l = index.length; p < l; p++) {\n      // number of values in row\n      w[index[p]]++;\n    } // cumulative sum\n\n\n    var sum = 0; // initialize cptr with the cummulative sum of row counts\n\n    for (var i = 0; i < rows; i++) {\n      // update cptr\n      cptr.push(sum); // update sum\n\n      sum += w[i]; // update w\n\n      w[i] = cptr[i];\n    } // update cptr\n\n\n    cptr.push(sum); // loop columns\n\n    for (j = 0; j < columns; j++) {\n      // values & index in column\n      for (var k0 = ptr[j], k1 = ptr[j + 1], k = k0; k < k1; k++) {\n        // C values & index\n        var q = w[index[k]]++; // C[j, i] = A[i, j]\n\n        cindex[q] = j; // check we need to process values (pattern matrix)\n\n        if (values) {\n          cvalues[q] = clone(values[k]);\n        }\n      }\n    } // return matrix\n\n\n    return m.createSparseMatrix({\n      values: cvalues,\n      index: cindex,\n      ptr: cptr,\n      size: [columns, rows],\n      datatype: m._datatype\n    });\n  }\n});","map":{"version":3,"sources":["C:/Users/x/Desktop/openDSA/openDSA_dashboard/project/node_modules/mathjs/lib/esm/function/matrix/transpose.js"],"names":["clone","format","factory","name","dependencies","createTranspose","_ref","typed","matrix","Array","x","transposeMatrix","valueOf","Matrix","any","size","c","length","rows","columns","RangeError","storage","_denseTranspose","_sparseTranspose","m","data","_data","transposed","transposedRow","j","i","createDenseMatrix","datatype","_datatype","values","_values","index","_index","ptr","_ptr","cvalues","undefined","cindex","cptr","w","p","l","sum","push","k0","k1","k","q","createSparseMatrix"],"mappings":"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","sourcesContent":["import { clone } from '../../utils/object.js';\r\nimport { format } from '../../utils/string.js';\r\nimport { factory } from '../../utils/factory.js';\r\nvar name = 'transpose';\r\nvar dependencies = ['typed', 'matrix'];\r\nexport var createTranspose = /* #__PURE__ */factory(name, dependencies, _ref => {\r\n  var {\r\n    typed,\r\n    matrix\r\n  } = _ref;\r\n  /**\r\n   * Transpose a matrix. All values of the matrix are reflected over its\r\n   * main diagonal. Only applicable to two dimensional matrices containing\r\n   * a vector (i.e. having size `[1,n]` or `[n,1]`). One dimensional\r\n   * vectors and scalars return the input unchanged.\r\n   *\r\n   * Syntax:\r\n   *\r\n   *     math.transpose(x)\r\n   *\r\n   * Examples:\r\n   *\r\n   *     const A = [[1, 2, 3], [4, 5, 6]]\r\n   *     math.transpose(A)               // returns [[1, 4], [2, 5], [3, 6]]\r\n   *\r\n   * See also:\r\n   *\r\n   *     diag, inv, subset, squeeze\r\n   *\r\n   * @param {Array | Matrix} x  Matrix to be transposed\r\n   * @return {Array | Matrix}   The transposed matrix\r\n   */\r\n  return typed(name, {\r\n    Array: x => transposeMatrix(matrix(x)).valueOf(),\r\n    Matrix: transposeMatrix,\r\n    any: clone // scalars\r\n  });\r\n\r\n  function transposeMatrix(x) {\r\n    // matrix size\r\n    var size = x.size();\r\n\r\n    // result\r\n    var c;\r\n\r\n    // process dimensions\r\n    switch (size.length) {\r\n      case 1:\r\n        // vector\r\n        c = x.clone();\r\n        break;\r\n      case 2:\r\n        {\r\n          // rows and columns\r\n          var rows = size[0];\r\n          var columns = size[1];\r\n\r\n          // check columns\r\n          if (columns === 0) {\r\n            // throw exception\r\n            throw new RangeError('Cannot transpose a 2D matrix with no columns (size: ' + format(size) + ')');\r\n          }\r\n\r\n          // process storage format\r\n          switch (x.storage()) {\r\n            case 'dense':\r\n              c = _denseTranspose(x, rows, columns);\r\n              break;\r\n            case 'sparse':\r\n              c = _sparseTranspose(x, rows, columns);\r\n              break;\r\n          }\r\n        }\r\n        break;\r\n      default:\r\n        // multi dimensional\r\n        throw new RangeError('Matrix must be a vector or two dimensional (size: ' + format(size) + ')');\r\n    }\r\n    return c;\r\n  }\r\n  function _denseTranspose(m, rows, columns) {\r\n    // matrix array\r\n    var data = m._data;\r\n    // transposed matrix data\r\n    var transposed = [];\r\n    var transposedRow;\r\n    // loop columns\r\n    for (var j = 0; j < columns; j++) {\r\n      // initialize row\r\n      transposedRow = transposed[j] = [];\r\n      // loop rows\r\n      for (var i = 0; i < rows; i++) {\r\n        // set data\r\n        transposedRow[i] = clone(data[i][j]);\r\n      }\r\n    }\r\n    // return matrix\r\n    return m.createDenseMatrix({\r\n      data: transposed,\r\n      size: [columns, rows],\r\n      datatype: m._datatype\r\n    });\r\n  }\r\n  function _sparseTranspose(m, rows, columns) {\r\n    // matrix arrays\r\n    var values = m._values;\r\n    var index = m._index;\r\n    var ptr = m._ptr;\r\n    // result matrices\r\n    var cvalues = values ? [] : undefined;\r\n    var cindex = [];\r\n    var cptr = [];\r\n    // row counts\r\n    var w = [];\r\n    for (var x = 0; x < rows; x++) {\r\n      w[x] = 0;\r\n    }\r\n    // vars\r\n    var p, l, j;\r\n    // loop values in matrix\r\n    for (p = 0, l = index.length; p < l; p++) {\r\n      // number of values in row\r\n      w[index[p]]++;\r\n    }\r\n    // cumulative sum\r\n    var sum = 0;\r\n    // initialize cptr with the cummulative sum of row counts\r\n    for (var i = 0; i < rows; i++) {\r\n      // update cptr\r\n      cptr.push(sum);\r\n      // update sum\r\n      sum += w[i];\r\n      // update w\r\n      w[i] = cptr[i];\r\n    }\r\n    // update cptr\r\n    cptr.push(sum);\r\n    // loop columns\r\n    for (j = 0; j < columns; j++) {\r\n      // values & index in column\r\n      for (var k0 = ptr[j], k1 = ptr[j + 1], k = k0; k < k1; k++) {\r\n        // C values & index\r\n        var q = w[index[k]]++;\r\n        // C[j, i] = A[i, j]\r\n        cindex[q] = j;\r\n        // check we need to process values (pattern matrix)\r\n        if (values) {\r\n          cvalues[q] = clone(values[k]);\r\n        }\r\n      }\r\n    }\r\n    // return matrix\r\n    return m.createSparseMatrix({\r\n      values: cvalues,\r\n      index: cindex,\r\n      ptr: cptr,\r\n      size: [columns, rows],\r\n      datatype: m._datatype\r\n    });\r\n  }\r\n});"]},"metadata":{},"sourceType":"module"}