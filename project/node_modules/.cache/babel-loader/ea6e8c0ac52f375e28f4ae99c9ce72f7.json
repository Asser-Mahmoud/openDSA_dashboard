{"ast":null,"code":"import { factory } from '../utils/factory.js';\nimport { createEmptyMap, toObject } from '../utils/map.js';\nvar name = 'Parser';\nvar dependencies = ['evaluate'];\nexport var createParserClass = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    evaluate\n  } = _ref;\n  /**\r\n   * @constructor Parser\r\n   * Parser contains methods to evaluate or parse expressions, and has a number\r\n   * of convenience methods to get, set, and remove variables from memory. Parser\r\n   * keeps a scope containing variables in memory, which is used for all\r\n   * evaluations.\r\n   *\r\n   * Methods:\r\n   *    const result = parser.evaluate(expr)  // evaluate an expression\r\n   *    const value = parser.get(name)        // retrieve a variable from the parser\r\n   *    const values = parser.getAll()        // retrieve all defined variables\r\n   *    parser.set(name, value)               // set a variable in the parser\r\n   *    parser.remove(name)                   // clear a variable from the\r\n   *                                          // parsers scope\r\n   *    parser.clear()                        // clear the parsers scope\r\n   *\r\n   * Example usage:\r\n   *    const parser = new Parser()\r\n   *    // Note: there is a convenience method which can be used instead:\r\n   *    // const parser = new math.parser()\r\n   *\r\n   *    // evaluate expressions\r\n   *    parser.evaluate('sqrt(3^2 + 4^2)')        // 5\r\n   *    parser.evaluate('sqrt(-4)')               // 2i\r\n   *    parser.evaluate('2 inch in cm')           // 5.08 cm\r\n   *    parser.evaluate('cos(45 deg)')            // 0.7071067811865476\r\n   *\r\n   *    // define variables and functions\r\n   *    parser.evaluate('x = 7 / 2')              // 3.5\r\n   *    parser.evaluate('x + 3')                  // 6.5\r\n   *    parser.evaluate('f(x, y) = x^y')          // f(x, y)\r\n   *    parser.evaluate('f(2, 3)')                // 8\r\n   *\r\n   *    // get and set variables and functions\r\n   *    const x = parser.get('x')                 // 7\r\n   *    const f = parser.get('f')                 // function\r\n   *    const g = f(3, 2)                         // 9\r\n   *    parser.set('h', 500)\r\n   *    const i = parser.evaluate('h / 2')        // 250\r\n   *    parser.set('hello', function (name) {\r\n   *        return 'hello, ' + name + '!'\r\n   *    })\r\n   *    parser.evaluate('hello(\"user\")')          // \"hello, user!\"\r\n   *\r\n   *    // clear defined functions and variables\r\n   *    parser.clear()\r\n   *\r\n   */\n\n  function Parser() {\n    if (!(this instanceof Parser)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    }\n\n    Object.defineProperty(this, 'scope', {\n      value: createEmptyMap(),\n      writable: false\n    });\n  }\n  /**\r\n   * Attach type information\r\n   */\n\n\n  Parser.prototype.type = 'Parser';\n  Parser.prototype.isParser = true;\n  /**\r\n   * Parse and evaluate the given expression\r\n   * @param {string | string[]} expr   A string containing an expression,\r\n   *                                   for example \"2+3\", or a list with expressions\r\n   * @return {*} result     The result, or undefined when the expression was empty\r\n   * @throws {Error}\r\n   */\n\n  Parser.prototype.evaluate = function (expr) {\n    // TODO: validate arguments\n    return evaluate(expr, this.scope);\n  };\n  /**\r\n   * Get a variable (a function or variable) by name from the parsers scope.\r\n   * Returns undefined when not found\r\n   * @param {string} name\r\n   * @return {* | undefined} value\r\n   */\n\n\n  Parser.prototype.get = function (name) {\n    // TODO: validate arguments\n    if (this.scope.has(name)) {\n      return this.scope.get(name);\n    }\n  };\n  /**\r\n   * Get a map with all defined variables\r\n   * @return {Object} values\r\n   */\n\n\n  Parser.prototype.getAll = function () {\n    return toObject(this.scope);\n  };\n  /**\r\n   * Get a map with all defined variables\r\n   * @return {Map} values\r\n   */\n\n\n  Parser.prototype.getAllAsMap = function () {\n    return this.scope;\n  };\n  /**\r\n   * Set a symbol (a function or variable) by name from the parsers scope.\r\n   * @param {string} name\r\n   * @param {* | undefined} value\r\n   */\n\n\n  Parser.prototype.set = function (name, value) {\n    this.scope.set(name, value);\n    return value;\n  };\n  /**\r\n   * Remove a variable from the parsers scope\r\n   * @param {string} name\r\n   */\n\n\n  Parser.prototype.remove = function (name) {\n    this.scope.delete(name);\n  };\n  /**\r\n   * Clear the scope with variables and functions\r\n   */\n\n\n  Parser.prototype.clear = function () {\n    this.scope.clear();\n  };\n\n  return Parser;\n}, {\n  isClass: true\n});","map":{"version":3,"sources":["C:/Users/x/Desktop/openDSA/openDSA_dashboard/project/node_modules/mathjs/lib/esm/expression/Parser.js"],"names":["factory","createEmptyMap","toObject","name","dependencies","createParserClass","_ref","evaluate","Parser","SyntaxError","Object","defineProperty","value","writable","prototype","type","isParser","expr","scope","get","has","getAll","getAllAsMap","set","remove","delete","clear","isClass"],"mappings":"AAAA,SAASA,OAAT,QAAwB,qBAAxB;AACA,SAASC,cAAT,EAAyBC,QAAzB,QAAyC,iBAAzC;AACA,IAAIC,IAAI,GAAG,QAAX;AACA,IAAIC,YAAY,GAAG,CAAC,UAAD,CAAnB;AACA,OAAO,IAAIC,iBAAiB,GAAG,eAAeL,OAAO,CAACG,IAAD,EAAOC,YAAP,EAAqBE,IAAI,IAAI;AAChF,MAAI;AACFC,IAAAA;AADE,MAEAD,IAFJ;AAGA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACE,WAASE,MAAT,GAAkB;AAChB,QAAI,EAAE,gBAAgBA,MAAlB,CAAJ,EAA+B;AAC7B,YAAM,IAAIC,WAAJ,CAAgB,kDAAhB,CAAN;AACD;;AACDC,IAAAA,MAAM,CAACC,cAAP,CAAsB,IAAtB,EAA4B,OAA5B,EAAqC;AACnCC,MAAAA,KAAK,EAAEX,cAAc,EADc;AAEnCY,MAAAA,QAAQ,EAAE;AAFyB,KAArC;AAID;AAED;AACF;AACA;;;AACEL,EAAAA,MAAM,CAACM,SAAP,CAAiBC,IAAjB,GAAwB,QAAxB;AACAP,EAAAA,MAAM,CAACM,SAAP,CAAiBE,QAAjB,GAA4B,IAA5B;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;;AACER,EAAAA,MAAM,CAACM,SAAP,CAAiBP,QAAjB,GAA4B,UAAUU,IAAV,EAAgB;AAC1C;AACA,WAAOV,QAAQ,CAACU,IAAD,EAAO,KAAKC,KAAZ,CAAf;AACD,GAHD;AAKA;AACF;AACA;AACA;AACA;AACA;;;AACEV,EAAAA,MAAM,CAACM,SAAP,CAAiBK,GAAjB,GAAuB,UAAUhB,IAAV,EAAgB;AACrC;AACA,QAAI,KAAKe,KAAL,CAAWE,GAAX,CAAejB,IAAf,CAAJ,EAA0B;AACxB,aAAO,KAAKe,KAAL,CAAWC,GAAX,CAAehB,IAAf,CAAP;AACD;AACF,GALD;AAOA;AACF;AACA;AACA;;;AACEK,EAAAA,MAAM,CAACM,SAAP,CAAiBO,MAAjB,GAA0B,YAAY;AACpC,WAAOnB,QAAQ,CAAC,KAAKgB,KAAN,CAAf;AACD,GAFD;AAIA;AACF;AACA;AACA;;;AACEV,EAAAA,MAAM,CAACM,SAAP,CAAiBQ,WAAjB,GAA+B,YAAY;AACzC,WAAO,KAAKJ,KAAZ;AACD,GAFD;AAIA;AACF;AACA;AACA;AACA;;;AACEV,EAAAA,MAAM,CAACM,SAAP,CAAiBS,GAAjB,GAAuB,UAAUpB,IAAV,EAAgBS,KAAhB,EAAuB;AAC5C,SAAKM,KAAL,CAAWK,GAAX,CAAepB,IAAf,EAAqBS,KAArB;AACA,WAAOA,KAAP;AACD,GAHD;AAKA;AACF;AACA;AACA;;;AACEJ,EAAAA,MAAM,CAACM,SAAP,CAAiBU,MAAjB,GAA0B,UAAUrB,IAAV,EAAgB;AACxC,SAAKe,KAAL,CAAWO,MAAX,CAAkBtB,IAAlB;AACD,GAFD;AAIA;AACF;AACA;;;AACEK,EAAAA,MAAM,CAACM,SAAP,CAAiBY,KAAjB,GAAyB,YAAY;AACnC,SAAKR,KAAL,CAAWQ,KAAX;AACD,GAFD;;AAGA,SAAOlB,MAAP;AACD,CAtIoD,EAsIlD;AACDmB,EAAAA,OAAO,EAAE;AADR,CAtIkD,CAA9C","sourcesContent":["import { factory } from '../utils/factory.js';\r\nimport { createEmptyMap, toObject } from '../utils/map.js';\r\nvar name = 'Parser';\r\nvar dependencies = ['evaluate'];\r\nexport var createParserClass = /* #__PURE__ */factory(name, dependencies, _ref => {\r\n  var {\r\n    evaluate\r\n  } = _ref;\r\n  /**\r\n   * @constructor Parser\r\n   * Parser contains methods to evaluate or parse expressions, and has a number\r\n   * of convenience methods to get, set, and remove variables from memory. Parser\r\n   * keeps a scope containing variables in memory, which is used for all\r\n   * evaluations.\r\n   *\r\n   * Methods:\r\n   *    const result = parser.evaluate(expr)  // evaluate an expression\r\n   *    const value = parser.get(name)        // retrieve a variable from the parser\r\n   *    const values = parser.getAll()        // retrieve all defined variables\r\n   *    parser.set(name, value)               // set a variable in the parser\r\n   *    parser.remove(name)                   // clear a variable from the\r\n   *                                          // parsers scope\r\n   *    parser.clear()                        // clear the parsers scope\r\n   *\r\n   * Example usage:\r\n   *    const parser = new Parser()\r\n   *    // Note: there is a convenience method which can be used instead:\r\n   *    // const parser = new math.parser()\r\n   *\r\n   *    // evaluate expressions\r\n   *    parser.evaluate('sqrt(3^2 + 4^2)')        // 5\r\n   *    parser.evaluate('sqrt(-4)')               // 2i\r\n   *    parser.evaluate('2 inch in cm')           // 5.08 cm\r\n   *    parser.evaluate('cos(45 deg)')            // 0.7071067811865476\r\n   *\r\n   *    // define variables and functions\r\n   *    parser.evaluate('x = 7 / 2')              // 3.5\r\n   *    parser.evaluate('x + 3')                  // 6.5\r\n   *    parser.evaluate('f(x, y) = x^y')          // f(x, y)\r\n   *    parser.evaluate('f(2, 3)')                // 8\r\n   *\r\n   *    // get and set variables and functions\r\n   *    const x = parser.get('x')                 // 7\r\n   *    const f = parser.get('f')                 // function\r\n   *    const g = f(3, 2)                         // 9\r\n   *    parser.set('h', 500)\r\n   *    const i = parser.evaluate('h / 2')        // 250\r\n   *    parser.set('hello', function (name) {\r\n   *        return 'hello, ' + name + '!'\r\n   *    })\r\n   *    parser.evaluate('hello(\"user\")')          // \"hello, user!\"\r\n   *\r\n   *    // clear defined functions and variables\r\n   *    parser.clear()\r\n   *\r\n   */\r\n  function Parser() {\r\n    if (!(this instanceof Parser)) {\r\n      throw new SyntaxError('Constructor must be called with the new operator');\r\n    }\r\n    Object.defineProperty(this, 'scope', {\r\n      value: createEmptyMap(),\r\n      writable: false\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Attach type information\r\n   */\r\n  Parser.prototype.type = 'Parser';\r\n  Parser.prototype.isParser = true;\r\n\r\n  /**\r\n   * Parse and evaluate the given expression\r\n   * @param {string | string[]} expr   A string containing an expression,\r\n   *                                   for example \"2+3\", or a list with expressions\r\n   * @return {*} result     The result, or undefined when the expression was empty\r\n   * @throws {Error}\r\n   */\r\n  Parser.prototype.evaluate = function (expr) {\r\n    // TODO: validate arguments\r\n    return evaluate(expr, this.scope);\r\n  };\r\n\r\n  /**\r\n   * Get a variable (a function or variable) by name from the parsers scope.\r\n   * Returns undefined when not found\r\n   * @param {string} name\r\n   * @return {* | undefined} value\r\n   */\r\n  Parser.prototype.get = function (name) {\r\n    // TODO: validate arguments\r\n    if (this.scope.has(name)) {\r\n      return this.scope.get(name);\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Get a map with all defined variables\r\n   * @return {Object} values\r\n   */\r\n  Parser.prototype.getAll = function () {\r\n    return toObject(this.scope);\r\n  };\r\n\r\n  /**\r\n   * Get a map with all defined variables\r\n   * @return {Map} values\r\n   */\r\n  Parser.prototype.getAllAsMap = function () {\r\n    return this.scope;\r\n  };\r\n\r\n  /**\r\n   * Set a symbol (a function or variable) by name from the parsers scope.\r\n   * @param {string} name\r\n   * @param {* | undefined} value\r\n   */\r\n  Parser.prototype.set = function (name, value) {\r\n    this.scope.set(name, value);\r\n    return value;\r\n  };\r\n\r\n  /**\r\n   * Remove a variable from the parsers scope\r\n   * @param {string} name\r\n   */\r\n  Parser.prototype.remove = function (name) {\r\n    this.scope.delete(name);\r\n  };\r\n\r\n  /**\r\n   * Clear the scope with variables and functions\r\n   */\r\n  Parser.prototype.clear = function () {\r\n    this.scope.clear();\r\n  };\r\n  return Parser;\r\n}, {\r\n  isClass: true\r\n});"]},"metadata":{},"sourceType":"module"}